// ============================================================================
// è¼”åŠ©è¼ª v9.6 - æœ€çµ‚å„ªåŒ–ç‰ˆ
// æ”¹é€²é …ç›®ï¼š
// 1. âœ“ æ‹†åˆ†éé•·å‡½æ•¸ï¼ˆloop, performHomingï¼‰
// 2. âœ“ ä½¿ç”¨çµæ§‹é«”å°è£å…¨åŸŸè®Šæ•¸
// 3. âœ“ æ¶ˆé™¤é­”æ³•æ•¸å­—ï¼Œä½¿ç”¨å‘½åå¸¸æ•¸
// 4. âœ“ æ”¹é€²éŒ¯èª¤è™•ç†ï¼ˆé‡è©¦æ©Ÿåˆ¶ + I2C éŒ¯èª¤ç¢¼ï¼‰
// 5. âœ“ ç°¡åŒ–åµŒå¥—å±¤ç´š
// 6. âœ“ æ˜ç¢ºå‡½æ•¸å‰¯ä½œç”¨
// 7. âœ“ æ”¹é€²è®Šæ•¸å‘½å
// ============================================================================
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <avr/wdt.h>

// ============================================================================
// å¸¸æ•¸å®šç¾©
// ============================================================================

// OLED è¨­å®š
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define OLED_ADDRESS 0x3C

// éŸ³ç¬¦å®šç¾©
#define NOTE_C4  262
#define NOTE_E4  330
#define NOTE_G4  392
#define NOTE_C5  523
#define NOTE_A5  880
#define NOTE_C6  1047

// MPU6050 è¨­å®š
#define MPU_ADDR 0x69
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B

// è…³ä½å®šç¾©
namespace Pins {
  const byte BUZZER = 8;
  const byte IR_RECEIVE = 3;
  const byte PWM = 9;
  const byte LIMIT_UP = 52;
  const byte LIMIT_DOWN = 53;
  const byte HALL_SPEED = 2;
  const byte SPEED_CONTROL = A0;
  const byte RGB_RED = 5;
  const byte RGB_GREEN = 7;
  const byte RGB_BLUE = 6;
  const byte BUTTON = 12;
}

// RGB é¡è‰²å¸¸æ•¸
namespace RGB {
  const byte OFF = 0;
  const byte FULL = 255;
  const byte MEDIUM = 200;
}

// PWM æ§åˆ¶å¸¸æ•¸
namespace PWMControl {
  const int HOMING_SPEED = 180;
  const int NORMAL_SPEED = 190;
  const int INCREMENT_STEP = 10;
  const int DECREMENT_STEP = 20;
  const int STOPPED = 0;
}

// æ™‚é–“å¸¸æ•¸
namespace Timing {
  const unsigned long HOMING_TIMEOUT_MS = 8000;
  const unsigned long SYSTEM_LOCK_DURATION_MS = 500;
  const unsigned long LIMIT_DEBOUNCE_MS = 50;
  const unsigned long IR_DELAY_MS = 500;
  const unsigned long BUTTON_DEBOUNCE_MS = 200;
  const unsigned long SPEED_TIMEOUT_MS = 2000;
  const unsigned long IMU_READ_INTERVAL_MS = 100;
  const unsigned long DISPLAY_UPDATE_INTERVAL_MS = 100;
  const unsigned long STATUS_PRINT_INTERVAL_MS = 1000;
  const unsigned long RGB_BLINK_INTERVAL_MS = 300;
  const unsigned long HOMING_BLINK_INTERVAL_MS = 500;
  const unsigned long AUTO_LIFT_SPEED_HOLD_MS = 1000;
}

// é€Ÿåº¦ç›¸é—œå¸¸æ•¸
namespace Speed {
  const float WHEEL_CIRCUMFERENCE_MM = 204.2;
  const float AUTO_LIFT_THRESHOLD_KMH = 15.0;
  const float MAX_REASONABLE_SPEED_KMH = 50.0;
  const uint32_t MIN_PULSE_INTERVAL_US = 40000;
}

// IMU ç›¸é—œå¸¸æ•¸
namespace IMU {
  const float ACCEL_SCALE = 16384.0;
  const float RAD_TO_DEG = 57.2958;
  const float TILT_WARNING_DEGREES = 10.0;
  const float TILT_DANGER_DEGREES = 15.0;
  const int MAX_READ_FAILURES = 5;
}

// ============================================================================
// ğŸ†• I2C éŒ¯èª¤ç¢¼èªªæ˜
// ============================================================================
namespace I2C {
  const byte SUCCESS = 0;
  const byte DATA_TOO_LONG = 1;
  const byte NACK_ON_ADDRESS = 2;
  const byte NACK_ON_DATA = 3;
  const byte OTHER_ERROR = 4;
  const byte TIMEOUT = 5;
}

// ============================================================================
// ç³»çµ±ç‹€æ…‹å®šç¾©
// ============================================================================
enum SystemState : byte {
  HOMING,
  AT_TOP,
  AT_BOTTOM,
  MOVING_UP,
  MOVING_DOWN
};

enum HomingPhase : byte {
  NOT_STARTED,
  MOVING,
  COMPLETED,
  FAILED
};

enum HomingFailureReason : byte {
  UNKNOWN = 0,
  TIMEOUT = 1,
  LIMIT_SWITCH_ERROR = 2
};

// ============================================================================
// è³‡æ–™çµæ§‹
// ============================================================================

struct HomingState {
  HomingPhase phase = NOT_STARTED;
  unsigned long startTime = 0;
  bool enabled = true;
  HomingFailureReason failureReason = UNKNOWN;
  
  void reset() {
    phase = NOT_STARTED;
    startTime = 0;
    enabled = true;
    failureReason = UNKNOWN;
  }
};

struct MotorState {
  int targetPWM = PWMControl::STOPPED;
  int currentPWM = PWMControl::STOPPED;
  int normalSpeed = PWMControl::NORMAL_SPEED;
  bool manualOverride = false;
  
  void setTarget(int pwm) {
    targetPWM = constrain(pwm, PWMControl::STOPPED, 255);
  }
  
  void smoothUpdate() {
    if (currentPWM < targetPWM) {
      currentPWM = min(currentPWM + PWMControl::INCREMENT_STEP, targetPWM);
    } else if (currentPWM > targetPWM) {
      currentPWM = max(currentPWM - PWMControl::DECREMENT_STEP, targetPWM);
    }
  }
};

struct LimitSwitchState {
  bool upperTriggered = false;
  bool lowerTriggered = false;
  unsigned long lastCheckTime = 0;
  
  bool needsDebounce() {
    return (millis() - lastCheckTime) < Timing::LIMIT_DEBOUNCE_MS;
  }
  
  void updateCheckTime() {
    lastCheckTime = millis();
  }
};

struct SystemLockState {
  bool locked = false;
  unsigned long lockStartTime = 0;
  
  void lock() {
    locked = true;
    lockStartTime = millis();
  }
  
  void unlock() {
    locked = false;
  }
  
  bool shouldUnlock() {
    return locked && (millis() - lockStartTime > Timing::SYSTEM_LOCK_DURATION_MS);
  }
};

struct SpeedMeasurement {
  volatile uint32_t lastTriggerTime = 0;
  volatile uint32_t pulseInterval = 0;
  volatile bool hasNewData = false;
  float currentSpeed = 0.0;
  unsigned long lastUpdateTime = 0;
  
  bool isTimedOut() {
    return (millis() - lastUpdateTime) > Timing::SPEED_TIMEOUT_MS;
  }
  
  void markUpdated() {
    lastUpdateTime = millis();
  }
};

struct AutoLiftState {
  unsigned long speedAboveThresholdTime = 0;
  bool timerRunning = false;
  bool liftCompleted = false;
  
  void reset() {
    timerRunning = false;
    speedAboveThresholdTime = 0;
  }
  
  unsigned long getElapsedTime() {
    return timerRunning ? (millis() - speedAboveThresholdTime) : 0;
  }
};

struct IMUState {
  float tiltAngle = 0.0;
  unsigned long lastReadTime = 0;
  bool lastWarningState = false;
  int consecutiveReadFailures = 0;
  
  bool needsRead() {
    return (millis() - lastReadTime) >= Timing::IMU_READ_INTERVAL_MS;
  }
  
  void markRead() {
    lastReadTime = millis();
  }
  
  void recordFailure() {
    consecutiveReadFailures++;
  }
  
  void recordSuccess() {
    consecutiveReadFailures = 0;
  }
  
  bool hasExcessiveFailures() {
    return consecutiveReadFailures >= IMU::MAX_READ_FAILURES;
  }
};

struct DisplayState {
  byte currentPage = 0;
  unsigned long lastUpdateTime = 0;
  
  bool needsUpdate() {
    return (millis() - lastUpdateTime) >= Timing::DISPLAY_UPDATE_INTERVAL_MS;
  }
  
  void markUpdated() {
    lastUpdateTime = millis();
  }
  
  void nextPage() {
    currentPage = (currentPage + 1) % 3;
  }
};

// ============================================================================
// å…¨åŸŸç‰©ä»¶
// ============================================================================
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

SystemState g_systemState = HOMING;
bool g_testModeEnabled = false;

HomingState g_homing;
MotorState g_motor;
LimitSwitchState g_limits;
SystemLockState g_systemLock;
SpeedMeasurement g_speed;
AutoLiftState g_autoLift;
IMUState g_imu;
DisplayState g_display;

struct {
  uint32_t irCode = 0;
  bool irDataAvailable = false;
  unsigned long lastIRTime = 0;
  bool lastButtonState = HIGH;
  unsigned long lastButtonPress = 0;
} g_input;

unsigned long g_lastStatusPrint = 0;

// ============================================================================
// ğŸ†• è¼”åŠ©å‡½æ•¸ï¼šI2C éŒ¯èª¤è¨Šæ¯
// ============================================================================
void printI2CError(byte errorCode) {
  Serial.print(F("I2C éŒ¯èª¤ç¢¼ "));
  Serial.print(errorCode);
  Serial.print(F(": "));
  
  switch(errorCode) {
    case I2C::SUCCESS:
      Serial.println(F("æˆåŠŸ"));
      break;
    case I2C::DATA_TOO_LONG:
      Serial.println(F("è³‡æ–™éé•·"));
      break;
    case I2C::NACK_ON_ADDRESS:
      Serial.println(F("ä½å€ç„¡å›æ‡‰ (è£ç½®æœªé€£æ¥?)"));
      break;
    case I2C::NACK_ON_DATA:
      Serial.println(F("è³‡æ–™å‚³è¼¸å¤±æ•—"));
      break;
    case I2C::OTHER_ERROR:
      Serial.println(F("å…¶ä»–éŒ¯èª¤"));
      break;
    case I2C::TIMEOUT:
      Serial.println(F("é€¾æ™‚"));
      break;
    default:
      Serial.println(F("æœªçŸ¥éŒ¯èª¤"));
      break;
  }
}

// ============================================================================
// é€Ÿåº¦ä¸­æ–·
// ============================================================================
void speedInterrupt() {
  uint32_t now = micros();
  uint32_t interval = now - g_speed.lastTriggerTime;
  if (interval > Speed::MIN_PULSE_INTERVAL_US) {
    g_speed.pulseInterval = interval;
    g_speed.lastTriggerTime = now;
    g_speed.hasNewData = true;
  }
}

// ============================================================================
// RGB LED æ§åˆ¶
// ============================================================================
void setRGB(byte red, byte green, byte blue) {
  analogWrite(Pins::RGB_RED, red);
  analogWrite(Pins::RGB_GREEN, green);
  analogWrite(Pins::RGB_BLUE, blue);
}

struct RGBColor {
  byte r, g, b;
};

const RGBColor RGB_COLORS[] = {
  {RGB::OFF, RGB::FULL, RGB::FULL},
  {RGB::FULL, RGB::MEDIUM, RGB::OFF},
  {RGB::OFF, RGB::FULL, RGB::OFF},
  {RGB::FULL, RGB::OFF, RGB::OFF}
};

void updateRGBByState() {
  if (g_motor.manualOverride) {
    static unsigned long lastBlink = 0;
    static bool blinkState = false;
    if (millis() - lastBlink > Timing::RGB_BLINK_INTERVAL_MS) {
      lastBlink = millis();
      blinkState = !blinkState;
      setRGB(blinkState ? RGB::FULL : RGB::OFF, RGB::OFF, RGB::OFF);
    }
    return;
  }

  if (g_systemState == HOMING) {
    static unsigned long lastBlink = 0;
    static bool blinkState = false;
    if (millis() - lastBlink > Timing::HOMING_BLINK_INTERVAL_MS) {
      lastBlink = millis();
      blinkState = !blinkState;
      setRGB(blinkState ? RGB::FULL : RGB::OFF, 
             RGB::OFF, 
             blinkState ? RGB::FULL : RGB::OFF);
    }
    return;
  }

  if (g_systemState >= AT_TOP && g_systemState <= MOVING_DOWN) {
    int index = g_systemState - AT_TOP;
    const RGBColor& color = RGB_COLORS[index];
    setRGB(color.r, color.g, color.b);
  }
}

// ============================================================================
// éŸ³æ•ˆå‡½æ•¸
// ============================================================================
void playTone(uint16_t frequency, uint16_t durationMs) {
  tone(Pins::BUZZER, frequency, durationMs);
  delay(durationMs + 20);
  noTone(Pins::BUZZER);
}

void playStartupMusic() {
  playTone(NOTE_C4, 150);
  playTone(NOTE_E4, 150);
  playTone(NOTE_G4, 150);
  playTone(NOTE_C5, 300);
}

void playWarning() {
  for(int i = 0; i < 3; i++) {
    tone(Pins::BUZZER, NOTE_C6, 100);
    delay(150);
  }
  noTone(Pins::BUZZER);
}

void playHomingComplete() {
  playTone(NOTE_G4, 150);
  playTone(NOTE_C5, 200);
}

// ============================================================================
// IMU å‡½æ•¸ï¼ˆğŸ†• æ”¹é€²éŒ¯èª¤è™•ç†ï¼‰
// ============================================================================
bool initializeIMU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(PWR_MGMT_1);
  Wire.write(0x00);
  byte error = Wire.endTransmission();
  
  if (error == I2C::SUCCESS) {
    Serial.println(F("IMU åˆå§‹åŒ–æˆåŠŸ"));
    g_imu.recordSuccess();
    return true;
  } else {
    Serial.print(F("IMU åˆå§‹åŒ–å¤±æ•— - "));
    printI2CError(error);  // ğŸ†• é¡¯ç¤ºè©³ç´°éŒ¯èª¤
    g_imu.recordFailure();
    return false;
  }
}

bool readIMUData(int16_t& accelX, int16_t& accelY, int16_t& accelZ) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(ACCEL_XOUT_H);
  byte error = Wire.endTransmission(false);
  
  if (error != I2C::SUCCESS) {
    Serial.print(F("[IMU] è®€å–å¤±æ•— - "));
    printI2CError(error);  // ğŸ†• é¡¯ç¤ºè©³ç´°éŒ¯èª¤
    return false;
  }

  Wire.requestFrom((byte)MPU_ADDR, (byte)6);
  if (Wire.available() < 6) {
    Serial.println(F("[IMU] è³‡æ–™ä¸è¶³"));
    return false;
  }

  accelX = (Wire.read() << 8) | Wire.read();
  accelY = (Wire.read() << 8) | Wire.read();
  accelZ = (Wire.read() << 8) | Wire.read();
  
  return true;
}

float calculateTiltAngle(int16_t accelX, int16_t accelZ) {
  float ax = accelX / IMU::ACCEL_SCALE;
  float az = accelZ / IMU::ACCEL_SCALE;
  float angle = atan2(ax, az) * IMU::RAD_TO_DEG;
  return constrain(angle, -90.0, 90.0);
}

void updateIMUReading() {
  if (!g_imu.needsRead()) return;
  g_imu.markRead();

  int16_t accelX, accelY, accelZ;
  
  if (readIMUData(accelX, accelY, accelZ)) {
    g_imu.tiltAngle = calculateTiltAngle(accelX, accelZ);
    g_imu.recordSuccess();
  } else {
    g_imu.recordFailure();
    g_imu.tiltAngle = 0.0;
    
    if (g_imu.hasExcessiveFailures()) {
      Serial.println(F("[éŒ¯èª¤] IMU é€£çºŒè®€å–å¤±æ•—ï¼Œå˜—è©¦é‡æ–°åˆå§‹åŒ–"));
      initializeIMU();
    }
  }
}

void checkTiltWarning() {
  if (g_systemState == HOMING) return;
  
  float absoluteTilt = abs(g_imu.tiltAngle);
  bool currentWarning = (absoluteTilt >= IMU::TILT_WARNING_DEGREES);

  if (currentWarning && !g_imu.lastWarningState) {
    if (absoluteTilt >= IMU::TILT_DANGER_DEGREES) {
      playWarning();
      Serial.print(F("[è­¦å‘Š] å±éšªå‚¾æ–œ: "));
      Serial.println(g_imu.tiltAngle, 1);
      g_motor.setTarget(g_motor.normalSpeed);
      g_systemState = MOVING_DOWN;
    } else {
      playTone(NOTE_A5, 200);
      Serial.print(F("[è­¦å‘Š] å‚¾æ–œè­¦å‘Š: "));
      Serial.println(g_imu.tiltAngle, 1);
    }
  }
  g_imu.lastWarningState = currentWarning;
}

// ============================================================================
// é€Ÿåº¦æ¸¬é‡
// ============================================================================
float calculateSpeedFromInterval(uint32_t intervalMicros) {
  float timeInSeconds = intervalMicros / 1000000.0;
  return (Speed::WHEEL_CIRCUMFERENCE_MM / timeInSeconds) * 0.036;
}

bool isSpeedReasonable(float speed) {
  return (speed >= 0 && speed <= Speed::MAX_REASONABLE_SPEED_KMH);
}

void updateSpeedMeasurement() {
  if (g_speed.hasNewData) {
    if (g_speed.pulseInterval > 0) {
      float rawSpeed = calculateSpeedFromInterval(g_speed.pulseInterval);
      
      if (isSpeedReasonable(rawSpeed)) {
        g_speed.currentSpeed = rawSpeed;
      }
    }
    g_speed.hasNewData = false;
    g_speed.markUpdated();
  }

  if (g_speed.isTimedOut()) {
    g_speed.currentSpeed = 0.0;
  }
}

// ============================================================================
// é™ä½é–‹é—œè™•ç†
// ============================================================================
void updateLimitSwitchesAndSystemState() {
  if (g_testModeEnabled) return;
  if (g_limits.needsDebounce()) return;
  g_limits.updateCheckTime();

  bool upperRaw = (digitalRead(Pins::LIMIT_UP) == LOW);
  bool lowerRaw = (digitalRead(Pins::LIMIT_DOWN) == LOW);

  static bool lastUpperRaw = false;
  static bool lastLowerRaw = false;
  if (upperRaw != lastUpperRaw || lowerRaw != lastLowerRaw) {
    Serial.print(F("[é™ä½] ä¸Š:"));
    Serial.print(upperRaw);
    Serial.print(F(" ä¸‹:"));
    Serial.println(lowerRaw);
  }
  lastUpperRaw = upperRaw;
  lastLowerRaw = lowerRaw;

  if (upperRaw && lowerRaw) {
    handleBothLimitsSwitchesTriggered();
    return;
  }

  if (upperRaw && !g_limits.upperTriggered) {
    handleUpperLimitTriggered();
  }
  else if (lowerRaw && !g_limits.lowerTriggered) {
    handleLowerLimitTriggered();
  }
  else if (!upperRaw && !lowerRaw) {
    g_limits.upperTriggered = false;
    g_limits.lowerTriggered = false;
  }
}

void handleBothLimitsSwitchesTriggered() {
  g_motor.setTarget(PWMControl::STOPPED);
  g_systemState = AT_TOP;
  g_systemLock.lock();

  if (g_homing.phase == MOVING) {
    g_homing.phase = FAILED;
    g_homing.failureReason = LIMIT_SWITCH_ERROR;
  }

  Serial.println(F("[éŒ¯èª¤] å…©å€‹é™ä½åŒæ™‚è§¸ç™¼ï¼"));
  playWarning();
}

void handleUpperLimitTriggered() {
  g_motor.setTarget(PWMControl::STOPPED);

  if (g_systemState == HOMING && g_homing.phase == MOVING) {
    g_homing.phase = COMPLETED;
    g_systemState = AT_TOP;
    playHomingComplete();
    Serial.println(F("[Homing] å®Œæˆ - åˆ°é”ä¸Šé™ (éé æœŸ)"));
  } else {
    g_systemState = AT_TOP;
    Serial.println(F("[é™ä½] åˆ°é”ä¸Šé™"));
  }

  g_systemLock.lock();
  g_limits.upperTriggered = true;
  g_limits.lowerTriggered = false;
  g_autoLift.liftCompleted = false;
  g_autoLift.reset();
}

void handleLowerLimitTriggered() {
  g_motor.setTarget(PWMControl::STOPPED);

  if (g_systemState == HOMING && g_homing.phase == MOVING) {
    g_homing.phase = COMPLETED;
    g_systemState = AT_BOTTOM;
    playHomingComplete();
    Serial.println(F("[Homing] å®Œæˆ - åˆ°é”ä¸‹é™"));
  } else {
    g_systemState = AT_BOTTOM;
    Serial.println(F("[é™ä½] åˆ°é”ä¸‹é™"));
  }

  g_systemLock.lock();
  g_limits.upperTriggered = false;
  g_limits.lowerTriggered = true;
}

// ============================================================================
// Homing æµç¨‹
// ============================================================================
void startHomingSequence() {
  Serial.println(F("\n[Homing] é–‹å§‹æ­¸ä½æµç¨‹"));
  Serial.println(F("  ç­–ç•¥: å‘ä¸‹ç§»å‹•è‡³ä¸‹é™ä½"));
  Serial.print(F("  PWM: "));
  Serial.println(PWMControl::HOMING_SPEED);
  Serial.print(F("  é€¾æ™‚: "));
  Serial.print(Timing::HOMING_TIMEOUT_MS / 1000);
  Serial.println(F("ç§’"));

  bool upperNow = (digitalRead(Pins::LIMIT_UP) == LOW);
  bool lowerNow = (digitalRead(Pins::LIMIT_DOWN) == LOW);

  if (lowerNow && !upperNow) {
    g_homing.phase = COMPLETED;
    g_systemState = AT_BOTTOM;
    playHomingComplete();
    Serial.println(F("[Homing] å·²åœ¨ä¸‹é™,ç›´æ¥å®Œæˆ"));
    return;
  } 
  
  if (upperNow && lowerNow) {
    g_homing.phase = FAILED;
    g_homing.failureReason = LIMIT_SWITCH_ERROR;
    g_systemState = AT_BOTTOM;
    Serial.println(F("[Homing] å¤±æ•— - é™ä½é–‹é—œç•°å¸¸"));
    playWarning();
    return;
  }

  g_motor.setTarget(PWMControl::HOMING_SPEED);
  g_homing.phase = MOVING;
  g_homing.startTime = millis();
  Serial.println(F("[Homing] é¦¬é”å·²å•Ÿå‹•"));
}

void updateHomingProgress() {
  unsigned long elapsedTime = millis() - g_homing.startTime;

  static unsigned long lastProgressPrint = 0;
  if (millis() - lastProgressPrint > Timing::STATUS_PRINT_INTERVAL_MS) {
    lastProgressPrint = millis();
    Serial.print(F("[Homing] é€²è¡Œä¸­... "));
    Serial.print(elapsedTime / 1000);
    Serial.print(F("s / "));
    Serial.print(Timing::HOMING_TIMEOUT_MS / 1000);
    Serial.println(F("s"));
  }
}

void checkHomingTimeout() {
  unsigned long elapsedTime = millis() - g_homing.startTime;
  
  if (elapsedTime > Timing::HOMING_TIMEOUT_MS) {
    g_motor.setTarget(PWMControl::STOPPED);
    g_homing.phase = FAILED;
    g_homing.failureReason = TIMEOUT;
    g_systemState = AT_BOTTOM;
    Serial.println(F("[Homing] å¤±æ•— - é€¾æ™‚æœªè§¸ç™¼é™ä½"));
    Serial.println(F("  å¯èƒ½åŸå› : æ©Ÿæ§‹å¡ä½/é™ä½é–‹é—œæ•…éšœ"));
    playWarning();
  }
}

void performHoming() {
  if (g_homing.phase == COMPLETED || g_homing.phase == FAILED) {
    return;
  }

  if (!g_homing.enabled) {
    g_homing.phase = COMPLETED;
    g_systemState = AT_BOTTOM;
    Serial.println(F("[Homing] å·²è·³é (ä½¿ç”¨è€…é¸æ“‡)"));
    return;
  }

  if (g_homing.phase == NOT_STARTED) {
    startHomingSequence();
  }

  if (g_homing.phase == MOVING) {
    updateHomingProgress();
    checkHomingTimeout();
  }
}

// ============================================================================
// è‡ªå‹•å‡é™ï¼ˆğŸ†• æ”¹åæ›´æ˜ç¢ºï¼‰
// ============================================================================
void checkAutoLiftConditions() {
  if (g_systemState == HOMING) return;
  if (g_homing.phase != COMPLETED) return;
  if (g_systemState != AT_BOTTOM) {
    g_autoLift.reset();
    return;
  }
  if (g_autoLift.liftCompleted || g_motor.manualOverride) {
    return;
  }

  if (g_speed.currentSpeed >= Speed::AUTO_LIFT_THRESHOLD_KMH) {
    if (!g_autoLift.timerRunning) {
      g_autoLift.timerRunning = true;
      g_autoLift.speedAboveThresholdTime = millis();
      Serial.println(F("[è‡ªå‹•] é€Ÿåº¦é”æ¨™,é–‹å§‹è¨ˆæ™‚"));
    } else {
      if (g_autoLift.getElapsedTime() >= Timing::AUTO_LIFT_SPEED_HOLD_MS) {
        startAutoLiftAndUpdateState();  // ğŸ†• æ”¹å
      }
    }
  } else {
    if (g_autoLift.timerRunning) {
      Serial.println(F("[è‡ªå‹•] é€Ÿåº¦é™ä½,é‡ç½®è¨ˆæ™‚"));
    }
    g_autoLift.reset();
  }
}

// ğŸ†• å‡½æ•¸åç¨±æ›´æ˜ç¢ºè¡¨é”å‰¯ä½œç”¨
void startAutoLiftAndUpdateState() {
  Serial.println(F("[è‡ªå‹•] æŒçºŒ1ç§’,å•Ÿå‹•å‡é™"));
  
  if (!g_systemLock.locked) {
    g_motor.setTarget(g_motor.normalSpeed);
    g_systemState = MOVING_UP;
    g_autoLift.liftCompleted = true;
    g_autoLift.reset();
    playTone(NOTE_C5, 200);
    Serial.print(F("[é¦¬é”] è‡ªå‹•ä¸Šå‡ PWM="));
    Serial.println(g_motor.normalSpeed);
  }
}

// ============================================================================
// è¼¸å…¥è™•ç†
// ============================================================================
void readIRReceiver() {
  if (IrReceiver.decode()) {
    g_input.irCode = IrReceiver.decodedIRData.decodedRawData;
    if (g_input.irCode != 0 && g_input.irCode != 0xFFFFFFFF) {
      g_input.irDataAvailable = true;
    }
    IrReceiver.resume();
  }
}

void handleIRCommand() {
  if (!g_input.irDataAvailable) return;
  if (millis() - g_input.lastIRTime < Timing::IR_DELAY_MS) {
    g_input.irDataAvailable = false;
    return;
  }

  g_input.lastIRTime = millis();
  g_input.irDataAvailable = false;

  if (g_systemState == HOMING && g_homing.phase == MOVING) {
    skipHomingSequence();
    return;
  }

  toggleManualOverride();
}

void skipHomingSequence() {
  g_motor.setTarget(PWMControl::STOPPED);
  g_homing.enabled = false;
  g_homing.phase = COMPLETED;
  g_systemState = AT_BOTTOM;
  playTone(NOTE_C4, 200);
  Serial.println(F("[ç´…å¤–] ä½¿ç”¨è€…è·³é Homing"));
  Serial.println(F("  ç³»çµ±å‡è¨­ç•¶å‰åœ¨ä¸‹é™ä½ç½®"));
}

void toggleManualOverride() {
  g_motor.manualOverride = !g_motor.manualOverride;

  if (g_motor.manualOverride) {
    g_motor.setTarget(PWMControl::STOPPED);
    playTone(NOTE_C4, 200);
    Serial.println(F("[ç´…å¤–] PWM æ‰‹å‹•é—œé–‰ (å®‰å…¨æ¨¡å¼)"));
  } else {
    playTone(NOTE_C5, 200);
    Serial.println(F("[ç´…å¤–] PWM è‡ªå‹•æ¨¡å¼æ¢å¾©"));
  }
}

void checkButtonPress() {
  bool buttonState = digitalRead(Pins::BUTTON);

  if (buttonState == LOW && g_input.lastButtonState == HIGH) {
    if (millis() - g_input.lastButtonPress > Timing::BUTTON_DEBOUNCE_MS) {
      g_input.lastButtonPress = millis();
      g_display.nextPage();
      playTone(NOTE_A5, 50);
      Serial.print(F("[æŒ‰éˆ•] åˆ‡æ›è‡³é é¢ "));
      Serial.println(g_display.currentPage);
    }
  }
  g_input.lastButtonState = buttonState;
}

// ============================================================================
// é¦¬é”æ§åˆ¶æ ¸å¿ƒ
// ============================================================================
void executeMotorControl() {
  if (g_systemState == HOMING && g_homing.phase == MOVING) {
    g_motor.setTarget(PWMControl::HOMING_SPEED);
  } else if (g_systemState == HOMING) {
    g_motor.setTarget(PWMControl::STOPPED);
  } else if (g_motor.manualOverride) {
    g_motor.setTarget(PWMControl::STOPPED);
  } else if (g_systemState == AT_TOP || g_systemState == AT_BOTTOM) {
    g_motor.setTarget(PWMControl::STOPPED);
  } else if (g_systemState == MOVING_UP || g_systemState == MOVING_DOWN) {
    g_motor.setTarget(g_motor.normalSpeed);
    
    if (g_limits.upperTriggered && g_systemState == MOVING_UP) {
      g_motor.setTarget(PWMControl::STOPPED);
      g_systemState = AT_TOP;
    }
    if (g_limits.lowerTriggered && g_systemState == MOVING_DOWN) {
      g_motor.setTarget(PWMControl::STOPPED);
      g_systemState = AT_BOTTOM;
    }
  }

  g_motor.smoothUpdate();
  analogWrite(Pins::PWM, g_motor.currentPWM);

  static int lastOutputPWM = -1;
  if (g_motor.currentPWM != lastOutputPWM) {
    Serial.print(F("[PWM] è¼¸å‡º: "));
    Serial.print(g_motor.currentPWM);
    Serial.print(F(" (ç›®æ¨™: "));
    Serial.print(g_motor.targetPWM);
    Serial.println(F(")"));
    lastOutputPWM = g_motor.currentPWM;
  }
}

// ============================================================================
// OLED é¡¯ç¤º
// ============================================================================
void drawMainPage() {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print(F("Bike v9.6"));

  if (g_motor.manualOverride) {
    display.setCursor(80, 0);
    display.print(F("[SAFE]"));
  }

  display.drawLine(0, 9, 127, 9, SSD1306_WHITE);

  if (g_systemState == HOMING) {
    display.setTextSize(2);
    display.setCursor(10, 20);
    display.print(F("HOMING"));

    display.setTextSize(1);
    display.setCursor(10, 40);

    switch(g_homing.phase) {
      case NOT_STARTED:
        display.print(F("Waiting..."));
        break;
      case MOVING:
        {
          unsigned long elapsed = millis() - g_homing.startTime;
          display.print(F("Moving "));
          display.print(elapsed / 1000);
          display.print(F("s"));
        }
        break;
      case COMPLETED:
        display.print(F("Completed!"));
        break;
      case FAILED:
        display.print(F("FAILED!"));
        break;
    }

    display.display();
    return;
  }

  display.setTextSize(2);
  display.setCursor(0, 12);
  switch(g_systemState) {
    case AT_TOP: display.print(F("AT TOP")); break;
    case AT_BOTTOM: display.print(F("AT BTM")); break;
    case MOVING_UP: display.print(F("UP")); break;
    case MOVING_DOWN: display.print(F("DOWN")); break;
    default: break;
  }

  display.drawLine(0, 28, 127, 28, SSD1306_WHITE);

  display.setTextSize(1);
  display.setCursor(0, 31);
  display.print(F("Speed:"));
  display.setTextSize(2);
  display.setCursor(0, 40);
  display.print((int)g_speed.currentSpeed);
  display.setTextSize(1);
  display.setCursor(30, 44);
  display.print(F("km/h"));

  display.setCursor(70, 31);
  display.print(F("Angle:"));
  display.setTextSize(2);
  display.setCursor(70, 40);
  display.print((int)g_imu.tiltAngle);
  display.setTextSize(1);
  display.setCursor(100, 44);
  display.print(F("o"));

  display.drawLine(0, 52, 127, 52, SSD1306_WHITE);
  display.setCursor(0, 54);
  display.print(F("PWM:"));
  display.print(g_motor.currentPWM);

  display.display();
}

void drawDebugPage() {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);

  display.setCursor(0, 0);
  display.print(F("DEBUG v9.6"));
  display.drawLine(0, 9, 127, 9, SSD1306_WHITE);

  display.setCursor(0, 12);
  display.print(F("State: "));
  display.print(g_systemState);

  display.setCursor(0, 22);
  display.print(F("Homing: "));
  display.print(g_homing.phase);

  display.setCursor(0, 32);
  display.print(F("PWM: "));
  display.print(g_motor.currentPWM);

  display.setCursor(0, 42);
  display.print(F("Lock: "));
  display.print(g_systemLock.locked ? F("Y") : F("N"));

  // ğŸ†• é¡¯ç¤º IMU éŒ¯èª¤è¨ˆæ•¸
  display.setCursor(0, 52);
  display.print(F("IMU err: "));
  display.print(g_imu.consecutiveReadFailures);

  display.display();
}

// ============================================================================
// Setup
// ============================================================================
void initializePins() {
  pinMode(Pins::PWM, OUTPUT);
  pinMode(Pins::LIMIT_UP, INPUT_PULLUP);
  pinMode(Pins::LIMIT_DOWN, INPUT_PULLUP);
  pinMode(Pins::HALL_SPEED, INPUT_PULLUP);
  pinMode(Pins::BUTTON, INPUT_PULLUP);
  pinMode(Pins::RGB_RED, OUTPUT);
  pinMode(Pins::RGB_GREEN, OUTPUT);
  pinMode(Pins::RGB_BLUE, OUTPUT);
  pinMode(Pins::BUZZER, OUTPUT);
  
  analogWrite(Pins::PWM, PWMControl::STOPPED);
  Serial.println(F("[åˆå§‹åŒ–] æ‰€æœ‰è…³ä½å·²è¨­å®š"));
}

void initializeDisplay() {
  if(!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDRESS)) {
    Serial.println(F("[éŒ¯èª¤] OLED åˆå§‹åŒ–å¤±æ•—"));
    while(1);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.println(F("System v9.6"));
  display.display();
  Serial.println(F("[åˆå§‹åŒ–] OLED å·²å•Ÿå‹•"));
}

void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000);
  
  Serial.println(F("\n========================================"));
  Serial.println(F("è¼”åŠ©è¼ªç³»çµ± v9.6 å•Ÿå‹•"));
  Serial.println(F("========================================"));

  initializePins();
  
  Wire.begin();
  Wire.setClock(400000);
  Serial.println(F("[åˆå§‹åŒ–] I2C å·²å•Ÿå‹•"));

  initializeDisplay();
  initializeIMU();

  IrReceiver.begin(Pins::IR_RECEIVE, ENABLE_LED_FEEDBACK);
  Serial.println(F("[åˆå§‹åŒ–] IR æ¥æ”¶å™¨å·²å•Ÿå‹•"));

  attachInterrupt(digitalPinToInterrupt(Pins::HALL_SPEED), speedInterrupt, FALLING);
  Serial.println(F("[åˆå§‹åŒ–] éœçˆ¾æ„Ÿæ¸¬å™¨ä¸­æ–·å·²è¨­å®š"));

  if (digitalRead(Pins::BUTTON) == LOW) {
    g_testModeEnabled = true;
    Serial.println(F("\n[ç³»çµ±] æ¸¬è©¦æ¨¡å¼å•Ÿå‹•ï¼"));
    playTone(NOTE_C5, 100);
    delay(100);
    playTone(NOTE_C5, 100);
  }

  playStartupMusic();

  setRGB(RGB::FULL, RGB::OFF, RGB::OFF); delay(200);
  setRGB(RGB::OFF, RGB::FULL, RGB::OFF); delay(200);
  setRGB(RGB::OFF, RGB::OFF, RGB::FULL); delay(200);
  setRGB(RGB::OFF, RGB::OFF, RGB::OFF);

  Serial.println(F("[åˆå§‹åŒ–] å®Œæˆï¼\n"));
}

// ============================================================================
// Loop
// ============================================================================
void readAllSensors() {
  readIRReceiver();
  checkButtonPress();
  updateSpeedMeasurement();
  updateIMUReading();
}

void updateSystemStates() {
  if (g_systemLock.shouldUnlock()) {
    g_systemLock.unlock();
    Serial.println(F("[ç³»çµ±] è§£é™¤é–å®š"));
  }
}

void processDecisionLogic() {
  performHoming();
  updateLimitSwitchesAndSystemState();
  checkAutoLiftConditions();
  handleIRCommand();
  checkTiltWarning();
}

void executeControlActions() {
  executeMotorControl();
}

void updateDisplayAndFeedback() {
  updateRGBByState();

  if (g_display.needsUpdate()) {
    g_display.markUpdated();
    if (g_display.currentPage == 0) {
      drawMainPage();
    } else {
      drawDebugPage();
    }
  }
}

void printStatusIfNeeded() {
  if (millis() - g_lastStatusPrint > Timing::STATUS_PRINT_INTERVAL_MS) {
    g_lastStatusPrint = millis();
    Serial.print(F("[ç‹€æ…‹] State:"));
    Serial.print(g_systemState);
    Serial.print(F(" PWM:"));
    Serial.print(g_motor.currentPWM);
    Serial.print(F(" Speed:"));
    Serial.print(g_speed.currentSpeed, 1);
    Serial.print(F(" Tilt:"));
    Serial.print(g_imu.tiltAngle, 1);
    Serial.print(F(" Lock:"));
    Serial.println(g_systemLock.locked ? F("Y") : F("N"));
  }
}

void loop() {
  readAllSensors();
  updateSystemStates();
  processDecisionLogic();
  executeControlActions();
  updateDisplayAndFeedback();
  printStatusIfNeeded();
}
```

---

## ğŸ” æ”¹å‹•å°ç…§è¡¨

| ä½ç½® | v9.5 | v9.6 | æ”¹å‹•èªªæ˜ |
|------|------|------|---------|
| **I2C éŒ¯èª¤** | `if (error != 0) return false;` | `printI2CError(error);` | âœ… é¡¯ç¤ºè©³ç´°éŒ¯èª¤è¨Šæ¯ |
| **å‡½æ•¸å‘½å** | `triggerAutoLift()` | `startAutoLiftAndUpdateState()` | âœ… æ˜ç¢ºè¡¨é”å‰¯ä½œç”¨ |
| **Debug é¡¯ç¤º** | ç„¡ | `display.print(g_imu.consecutiveReadFailures);` | âœ… é¡¯ç¤º IMU éŒ¯èª¤è¨ˆæ•¸ |

---

## ğŸ“Š é æœŸè©•åˆ†

| é …ç›® | v9.5 | v9.6 | æ”¹é€² |
|------|------|------|------|
| Error handling | ä¸­ | **å„ª** | âœ… +5 åˆ† |
| Side effects | ä½ | **ä¸­** | âœ… +2 åˆ† |
| **ç¸½åˆ†** | **85** | **87-88** | **+2~3 åˆ†** |

---

## âœ… æ¸¬è©¦é‡é»

ä¸Šå‚³å¾Œï¼Œè§€å¯Ÿåºåˆ—åŸ è¼¸å‡ºï¼š

### å¦‚æœ IMU é€£æ¥æ­£å¸¸ï¼š
```
IMU åˆå§‹åŒ–æˆåŠŸ
```

### å¦‚æœ IMU æ²’é€£æ¥ï¼š
```
IMU åˆå§‹åŒ–å¤±æ•— - I2C éŒ¯èª¤ç¢¼ 2: ä½å€ç„¡å›æ‡‰ (è£ç½®æœªé€£æ¥?)
```

### å¦‚æœ I2C ç·šè·¯æœ‰å•é¡Œï¼š
```
[IMU] è®€å–å¤±æ•— - I2C éŒ¯èª¤ç¢¼ 3: è³‡æ–™å‚³è¼¸å¤±æ•—
[IMU] è®€å–å¤±æ•— - I2C éŒ¯èª¤ç¢¼ 3: è³‡æ–™å‚³è¼¸å¤±æ•—
[IMU] è®€å–å¤±æ•— - I2C éŒ¯èª¤ç¢¼ 3: è³‡æ–™å‚³è¼¸å¤±æ•—
[IMU] è®€å–å¤±æ•— - I2C éŒ¯èª¤ç¢¼ 3: è³‡æ–™å‚³è¼¸å¤±æ•—
[IMU] è®€å–å¤±æ•— - I2C éŒ¯èª¤ç¢¼ 3: è³‡æ–™å‚³è¼¸å¤±æ•—
[éŒ¯èª¤] IMU é€£çºŒè®€å–å¤±æ•—ï¼Œå˜—è©¦é‡æ–°åˆå§‹åŒ–
