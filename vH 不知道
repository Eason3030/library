// ============================================================================
// 輔助輪 v9.3 - 修正 PWM 初始化與 Homing 流程完整性
// ============================================================================
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <avr/wdt.h>

// ============================================================================
// OLED 顯示器設定
// ============================================================================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ============================================================================
// 音樂音符定義
// ============================================================================
#define NOTE_C4  262
#define NOTE_E4  330
#define NOTE_G4  392
#define NOTE_C5  523
#define NOTE_A5  880
#define NOTE_C6  1047

// ============================================================================
// MPU6050 加速度計設定
// ============================================================================
#define MPU_ADDR 0x69
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B

// ============================================================================
// 腳位定義
// ============================================================================
const byte BUZZER_PIN = 8;
const byte IR_RECEIVE_PIN = 3;
const byte PWM_PIN = 9;
const byte LIMIT_UP_PIN = 52;
const byte LIMIT_DOWN_PIN = 53;
const byte HALL_SPEED_PIN = 2;
const byte SPEED_CONTROL_PIN = A0;
const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;
const byte BUTTON_PIN = 12;

// ============================================================================
// 系統狀態定義
// ============================================================================
enum SystemState : byte {
HOMING,
AT_TOP,
AT_BOTTOM,
MOVING_UP,
MOVING_DOWN
};

enum HomingPhase : byte {
HOMING_NOT_STARTED,
HOMING_MOVING,
HOMING_COMPLETED,
HOMING_FAILED
};

// ============================================================================
// 全域變數
// ============================================================================
SystemState currentState = HOMING;
HomingPhase homingPhase = HOMING_NOT_STARTED;

// Homing 控制參數
const unsigned long HOMING_TIMEOUT = 8000;
const int HOMING_PWM_SPEED = 180;
unsigned long homingStartTime = 0;
bool homingEnabled = true;

// 測試模式標記
bool systemInTestMode = false;

// 限位開關
bool upperLimit = false;
bool lowerLimit = false;
unsigned long lastLimitCheck = 0;
const unsigned long LIMIT_DEBOUNCE = 50;

// 系統鎖定
bool systemLocked = false;
unsigned long lockStartTime = 0;
const unsigned long LOCK_DURATION = 500;

// PWM 控制
int pwmSpeed = 190;
unsigned long lastSpeedRead = 0;
bool pwmManualOverride = false;

// 速度測量
#define WHEEL_CIRCUMFERENCE 204.2
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t speedPulseInterval = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
unsigned long lastSpeedUpdate = 0;
const unsigned long SPEED_TIMEOUT = 2000;

// 自動升降
const float AUTO_LIFT_SPEED = 15.0;
const unsigned long SPEED_HOLD_TIME = 1000;
unsigned long speedAboveThresholdTime = 0;
bool speedTimerRunning = false;
bool autoLiftDone = false;

// 紅外線 (統一管理)
unsigned long lastIRTime = 0;
const unsigned long IR_DELAY = 500;
bool irDataAvailable = false;
uint32_t irCode = 0;

// OLED
byte currentPage = 0;
unsigned long lastDisplayUpdate = 0;

// 按鈕
bool lastButtonState = HIGH;
unsigned long lastButtonPress = 0;
const unsigned long BUTTON_DEBOUNCE = 200;

// 序列埠
unsigned long lastSerialPrint = 0;

// IMU
float tiltAngle = 0.0;
unsigned long lastIMURead = 0;
const unsigned long IMU_READ_INTERVAL = 100;
const float TILT_WARNING = 10.0;
const float TILT_DANGER = 15.0;
bool lastTiltWarning = false;

// ============================================================================
// 速度中斷
// ============================================================================
void speedInterrupt() {
uint32_t now = micros();
uint32_t interval = now - lastSpeedTrigger;
if (interval > 40000) {
speedPulseInterval = interval;
lastSpeedTrigger = now;
newSpeedData = true;
}
}

// ============================================================================
// RGB LED
// ============================================================================
void setRGB(byte r, byte g, byte b) {
analogWrite(RGB_RED_PIN, r);
analogWrite(RGB_GREEN_PIN, g);
analogWrite(RGB_BLUE_PIN, b);
}

void updateRGBByState() {
if (pwmManualOverride) {
static unsigned long lastBlink = 0;
static bool blinkState = false;
if (millis() - lastBlink > 300) {
lastBlink = millis();
blinkState = !blinkState;
setRGB(blinkState ? 255 : 0, 0, 0);
}
return;
}

switch(currentState) {
case HOMING:
static unsigned long lastHomingBlink = 0;
static bool homingBlinkState = false;
if (millis() - lastHomingBlink > 500) {
lastHomingBlink = millis();
homingBlinkState = !homingBlinkState;
setRGB(homingBlinkState ? 255 : 0, 0, homingBlinkState ? 255 : 0);
}
break;
case AT_TOP:
setRGB(0, 255, 255);
break;
case AT_BOTTOM:
setRGB(255, 200, 0);
break;
case MOVING_UP:
setRGB(0, 255, 0);
break;
case MOVING_DOWN:
setRGB(255, 0, 0);
break;
}
}

// ============================================================================
// 音效
// ============================================================================
void playStartupMusic() {
tone(BUZZER_PIN, NOTE_C4, 150); delay(180);
tone(BUZZER_PIN, NOTE_E4, 150); delay(180);
tone(BUZZER_PIN, NOTE_G4, 150); delay(180);
tone(BUZZER_PIN, NOTE_C5, 300); delay(350);
noTone(BUZZER_PIN);
}

void playBeep(uint16_t freq, uint16_t duration) {
tone(BUZZER_PIN, freq, duration);
delay(duration + 20);
noTone(BUZZER_PIN);
}

void playWarning() {
for(int i = 0; i < 3; i++) {
tone(BUZZER_PIN, NOTE_C6, 100);
delay(150);
}
noTone(BUZZER_PIN);
}

void playHomingComplete() {
tone(BUZZER_PIN, NOTE_G4, 150); delay(180);
tone(BUZZER_PIN, NOTE_C5, 200); delay(220);
noTone(BUZZER_PIN);
}

// ============================================================================
// MPU6050
// ============================================================================
void setupIMU() {
Wire.beginTransmission(MPU_ADDR);
Wire.write(PWR_MGMT_1);
Wire.write(0x00);
byte error = Wire.endTransmission();
if (error == 0) {
Serial.println(F(“IMU 初始化成功”));
} else {
Serial.println(F(“IMU 初始化失敗”));
}
delay(50);
}

void readIMU() {
if (millis() - lastIMURead < IMU_READ_INTERVAL) return;
lastIMURead = millis();

Wire.beginTransmission(MPU_ADDR);
Wire.write(ACCEL_XOUT_H);
byte error = Wire.endTransmission(false);
if (error != 0) {
tiltAngle = 0.0;
return;
}

Wire.requestFrom((byte)MPU_ADDR, (byte)4);
if (Wire.available() >= 4) {
int16_t ax = (Wire.read() << 8) | Wire.read();
int16_t ay = (Wire.read() << 8) | Wire.read();

```
Wire.beginTransmission(MPU_ADDR);
Wire.write(ACCEL_XOUT_H + 4);
Wire.endTransmission(false);
Wire.requestFrom((byte)MPU_ADDR, (byte)2);
int16_t az = (Wire.read() << 8) | Wire.read();

float accelX = ax / 16384.0;
float accelZ = az / 16384.0;
tiltAngle = atan2(accelX, accelZ) * 57.2958;
if (tiltAngle > 90) tiltAngle = 90;
if (tiltAngle < -90) tiltAngle = -90;
```

}
}

void checkTiltWarning() {
float absTilt = abs(tiltAngle);
bool currentWarning = (absTilt >= TILT_WARNING);

if (currentWarning && !lastTiltWarning) {
if (absTilt >= TILT_DANGER) {
playWarning();
Serial.print(F(”[警告] 危險傾斜: “));
Serial.println(tiltAngle, 1);
} else {
tone(BUZZER_PIN, NOTE_A5, 200);
delay(220);
noTone(BUZZER_PIN);
Serial.print(F(”[警告] 傾斜警告: “));
Serial.println(tiltAngle, 1);
}
}
lastTiltWarning = currentWarning;
}

// ============================================================================
// 速度計算
// ============================================================================
void updateSpeed() {
if (newSpeedData) {
if (speedPulseInterval > 0) {
float timeInSec = speedPulseInterval / 1000000.0;
currentSpeed = (WHEEL_CIRCUMFERENCE / timeInSec) * 0.036;
}
newSpeedData = false;
lastSpeedUpdate = millis();
}

if (millis() - lastSpeedUpdate > SPEED_TIMEOUT) {
currentSpeed = 0.0;
}
}

// ============================================================================
// 限位開關檢查 (修改版 - 在 Homing 期間更寬容)
// ============================================================================
void checkLimitSwitches() {
if (systemInTestMode) return;
if (millis() - lastLimitCheck < LIMIT_DEBOUNCE) return;
lastLimitCheck = millis();

bool upperRaw = (digitalRead(LIMIT_UP_PIN) == LOW);
bool lowerRaw = (digitalRead(LIMIT_DOWN_PIN) == LOW);

// 異常狀態優先處理
if (upperRaw && lowerRaw) {
analogWrite(PWM_PIN, 0);
currentState = AT_TOP;
systemLocked = true;
lockStartTime = millis();

```
if (homingPhase == HOMING_MOVING) {
  homingPhase = HOMING_FAILED;
}

Serial.println(F("[錯誤] 兩個限位同時觸發！"));
playWarning();
return;
```

}

// 上限位觸發
if (upperRaw && !lowerRaw) {
analogWrite(PWM_PIN, 0);

```
if (currentState == HOMING && homingPhase == HOMING_MOVING) {
  // Homing 到上限 - 這不是預期結果,但仍標記完成
  homingPhase = HOMING_COMPLETED;
  currentState = AT_TOP;
  playHomingComplete();
  Serial.println(F("[Homing] 完成 - 到達上限 (非預期)"));
} else {
  currentState = AT_TOP;
  if (homingPhase == HOMING_COMPLETED) {
    Serial.println(F("[限位] 到達上限"));
  }
}

systemLocked = true;
lockStartTime = millis();
upperLimit = true;
lowerLimit = false;
autoLiftDone = false;
speedTimerRunning = false;
```

// 下限位觸發
} else if (lowerRaw && !upperRaw) {
analogWrite(PWM_PIN, 0);

```
if (currentState == HOMING && homingPhase == HOMING_MOVING) {
  homingPhase = HOMING_COMPLETED;
  currentState = AT_BOTTOM;
  playHomingComplete();
  Serial.println(F("[Homing] 完成 - 到達下限"));
} else {
  currentState = AT_BOTTOM;
  if (homingPhase == HOMING_COMPLETED) {
    Serial.println(F("[限位] 到達下限"));
  }
}

systemLocked = true;
lockStartTime = millis();
upperLimit = false;
lowerLimit = true;
```

// 都沒觸發
} else {
upperLimit = false;
lowerLimit = false;
}
}

// ============================================================================
// Homing 歸位流程 (修改版 - 完整錯誤處理)
// ============================================================================
void performHoming() {
// 已完成或失敗,退出
if (homingPhase == HOMING_COMPLETED || homingPhase == HOMING_FAILED) {
return;
}

// 使用者跳過
if (!homingEnabled) {
homingPhase = HOMING_COMPLETED;
currentState = AT_BOTTOM;
Serial.println(F(”[Homing] 已跳過 (使用者選擇)”));
return;
}

// 首次執行:啟動歸位
if (homingPhase == HOMING_NOT_STARTED) {
Serial.println(F(”\n[Homing] 開始歸位流程”));
Serial.println(F(”  策略: 向下移動至下限位”));
Serial.print(F(”  PWM: “));
Serial.println(HOMING_PWM_SPEED);
Serial.print(F(”  逾時: “));
Serial.print(HOMING_TIMEOUT / 1000);
Serial.println(F(“秒”));

```
// 檢查當前限位狀態
bool upperNow = (digitalRead(LIMIT_UP_PIN) == LOW);
bool lowerNow = (digitalRead(LIMIT_DOWN_PIN) == LOW);

if (lowerNow && !upperNow) {
  // 已在下限,直接完成
  homingPhase = HOMING_COMPLETED;
  currentState = AT_BOTTOM;
  playHomingComplete();
  Serial.println(F("[Homing] 已在下限,直接完成"));
  return;
  
} else if (upperNow && !lowerNow) {
  Serial.println(F("[Homing] 從上限開始,向下移動"));
  
} else if (upperNow && lowerNow) {
  // 限位開關異常
  homingPhase = HOMING_FAILED;
  currentState = AT_BOTTOM;  // 容錯:假設在下限
  Serial.println(F("[Homing] 失敗 - 限位開關異常"));
  playWarning();
  return;
  
} else {
  Serial.println(F("[Homing] 從中間位置開始,向下移動"));
}

// 啟動馬達向下
analogWrite(PWM_PIN, HOMING_PWM_SPEED);
homingPhase = HOMING_MOVING;
homingStartTime = millis();
Serial.println(F("[Homing] 馬達已啟動"));
```

}

// 歸位進行中:監控進度與逾時
if (homingPhase == HOMING_MOVING) {
unsigned long elapsed = millis() - homingStartTime;

```
// 每秒輸出進度
static unsigned long lastProgressPrint = 0;
if (millis() - lastProgressPrint > 1000) {
  lastProgressPrint = millis();
  Serial.print(F("[Homing] 進行中... "));
  Serial.print(elapsed / 1000);
  Serial.print(F("s / "));
  Serial.print(HOMING_TIMEOUT / 1000);
  Serial.println(F("s"));
}

// 檢查逾時
if (elapsed > HOMING_TIMEOUT) {
  analogWrite(PWM_PIN, 0);
  homingPhase = HOMING_FAILED;
  currentState = AT_BOTTOM;  // 容錯:假設在下限
  Serial.println(F("[Homing] 失敗 - 逾時未觸發限位"));
  Serial.println(F("  可能原因: 機構卡住/限位開關故障"));
  playWarning();
}
```

}
}

// ============================================================================
// 馬達控制
// ============================================================================
void startMotorUp() {
if (currentState == HOMING || homingPhase != HOMING_COMPLETED) {
Serial.println(F(”[控制] Homing 未完成,拒絕”));
return;
}

if (pwmManualOverride) {
Serial.println(F(”[控制] PWM 手動關閉,拒絕”));
return;
}

if (systemLocked) {
Serial.println(F(”[控制] 系統鎖定,拒絕”));
return;
}

if (currentState == MOVING_UP) {
Serial.println(F(”[控制] 已在上升中”));
return;
}

if (currentState == AT_TOP) {
Serial.println(F(”[控制] 已在上限”));
return;
}

analogWrite(PWM_PIN, pwmSpeed);
currentState = MOVING_UP;
systemLocked = true;
lockStartTime = millis();
playBeep(NOTE_A5, 100);
Serial.print(F(”[馬達] 上升 PWM=”));
Serial.println(pwmSpeed);
}

void startMotorDown() {
if (currentState == HOMING || homingPhase != HOMING_COMPLETED) {
Serial.println(F(”[控制] Homing 未完成,拒絕”));
return;
}

if (pwmManualOverride) {
Serial.println(F(”[控制] PWM 手動關閉,拒絕”));
return;
}

if (systemLocked) {
Serial.println(F(”[控制] 系統鎖定,拒絕”));
return;
}

if (currentState == MOVING_DOWN) {
Serial.println(F(”[控制] 已在下降中”));
return;
}

if (currentState == AT_BOTTOM) {
Serial.println(F(”[控制] 已在下限”));
return;
}

analogWrite(PWM_PIN, pwmSpeed);
currentState = MOVING_DOWN;
systemLocked = true;
lockStartTime = millis();
playBeep(NOTE_A5, 100);
Serial.print(F(”[馬達] 下降 PWM=”));
Serial.println(pwmSpeed);
}

void stopMotor() {
analogWrite(PWM_PIN, 0);
Serial.println(F(”[馬達] 停止”));
}

// ============================================================================
// 自動升降
// ============================================================================
void checkAutoLift() {
if (currentState == HOMING || homingPhase != HOMING_COMPLETED) {
return;
}

if (currentState != AT_BOTTOM) {
speedTimerRunning = false;
speedAboveThresholdTime = 0;
return;
}

if (autoLiftDone || pwmManualOverride) {
return;
}

if (currentSpeed >= AUTO_LIFT_SPEED) {
if (!speedTimerRunning) {
speedTimerRunning = true;
speedAboveThresholdTime = millis();
Serial.println(F(”[自動] 速度達標,開始計時”));
} else {
unsigned long elapsed = millis() - speedAboveThresholdTime;
if (elapsed >= SPEED_HOLD_TIME) {
Serial.println(F(”[自動] 持續1秒,啟動升降”));
startMotorUp();
autoLiftDone = true;
speedTimerRunning = false;
playBeep(NOTE_C5, 200);
}
}
} else {
if (speedTimerRunning) {
Serial.println(F(”[自動] 速度降低,重置計時”));
}
speedTimerRunning = false;
speedAboveThresholdTime = 0;
}
}

// ============================================================================
// 紅外線接收 (統一管理)
// ============================================================================
void readIRReceiver() {
if (IrReceiver.decode()) {
irCode = IrReceiver.decodedIRData.decodedRawData;
if (irCode != 0 && irCode != 0xFFFFFFFF) {
irDataAvailable = true;
}
IrReceiver.resume();
}
}

void handleIR() {
if (!irDataAvailable) return;
if (millis() - lastIRTime < IR_DELAY) {
irDataAvailable = false;
return;
}

lastIRTime = millis();
irDataAvailable = false;

// Homing 進行中 - 紅外線可跳過
if (currentState == HOMING && homingPhase == HOMING_MOVING) {
analogWrite(PWM_PIN, 0);
homingEnabled = false;
homingPhase = HOMING_COMPLETED;
currentState = AT_BOTTOM;
playBeep(NOTE_C4, 200);
Serial.println(F(”[紅外] 使用者跳過 Homing”));
Serial.println(F(”  系統假設當前在下限位置”));
return;
}

// 正常模式 - 切換 PWM 開/關
pwmManualOverride = !pwmManualOverride;

if (pwmManualOverride) {
analogWrite(PWM_PIN, 0);
playBeep(NOTE_C4, 200);
Serial.println(F(”[紅外] PWM 手動關閉 (安全模式)”));
} else {
playBeep(NOTE_C5, 200);
Serial.println(F(”[紅外] PWM 自動模式恢復”));
}
}

// ============================================================================
// 按鈕處理
// ============================================================================
void checkButton() {
bool buttonState = digitalRead(BUTTON_PIN);

if (buttonState == LOW && lastButtonState == HIGH) {
if (millis() - lastButtonPress > BUTTON_DEBOUNCE) {
lastButtonPress = millis();
currentPage = (currentPage + 1) % 3;
playBeep(NOTE_A5, 50);
Serial.print(F(”[按鈕] 切換至頁面 “));
Serial.println(currentPage);
}
}
lastButtonState = buttonState;
}

// ============================================================================
// OLED 顯示
// ============================================================================
void drawMainPage() {
display.clearDisplay();
display.setTextColor(SSD1306_WHITE);

display.setTextSize(1);
display.setCursor(0, 0);
display.print(F(“Bike v9.3”));

if (pwmManualOverride) {
display.setCursor(80, 0);
display.print(F(”[SAFE]”));
}

display.drawLine(0, 9, 127, 9, SSD1306_WHITE);

if (currentState == HOMING) {
display.setTextSize(2);
display.setCursor(10, 20);
display.print(F(“HOMING”));

```
display.setTextSize(1);
display.setCursor(10, 40);

switch(homingPhase) {
  case HOMING_NOT_STARTED:
    display.print(F("Waiting..."));
    break;
  case HOMING_MOVING:
    {
      unsigned long elapsed = millis() - homingStartTime;
      display.print(F("Moving "));
      display.print(elapsed / 1000);
      display.print(F("s"));
    }
    break;
  case HOMING_COMPLETED:
    display.print(F("Completed!"));
    break;
  case HOMING_FAILED:
    display.print(F("FAILED!"));
    break;
}

display.setCursor(10, 52);
display.print(F("IR: Skip"));

display.display();
return;
```

}

display.setTextSize(2);
display.setCursor(0, 12);
switch(currentState) {
case AT_TOP: display.print(F(“AT TOP”)); break;
case AT_BOTTOM: display.print(F(“AT BTM”)); break;
case MOVING_UP: display.print(F(“UP”)); break;
case MOVING_DOWN: display.print(F(“DOWN”)); break;
default: break;
}

display.drawLine(0, 28, 127, 28, SSD1306_WHITE);

display.setTextSize(1);
display.setCursor(0, 31);
display.print(F(“Speed:”));

display.setTextSize(2);
display.setCursor(0, 40);
int speedInt = (int)currentSpeed;
if (speedInt < 10) display.print(F(” “));
display.print(speedInt);

display.setTextSize(1);
display.setCursor(30, 44);
display.print(F(“km/h”));

display.setCursor(70, 31);
display.print(F(“Angle:”));

display.setTextSize(2);
display.setCursor(70, 40);
int angleInt = (int)tiltAngle;
if (angleInt >= 0 && angleInt < 10) display.print(F(” “));
display.print(angleInt);

display.setTextSize(1);
display.setCursor(100, 44);
display.print(F(“o”));

if (abs(tiltAngle) >= TILT_DANGER) {
display.fillRect(110, 31, 18, 10, SSD1306_WHITE);
display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
display.setCursor(112, 32);
display.print(F(”!!!”));
display.setTextColor(SSD1306_WHITE);
}

display.drawLine(0, 52, 127, 52, SSD1306_WHITE);

display.setCursor(0, 54);
display.print(F(“PWM:”));
display.print(pwmSpeed);

if (speedTimerRunning) {
unsigned long elapsed = millis() - speedAboveThresholdTime;
unsigned long remaining = (SPEED_HOLD_TIME - elapsed) / 100;
display.setCursor(60, 54);
display.print(F(“Auto:”));
display.print(remaining / 10);
display.print(F(”.”));
display.print(remaining % 10);
}

display.display();
}

void drawDebugPage() {
display.clearDisplay();
display.setTextColor(SSD1306_WHITE);
display.setTextSize(1);

display.setCursor(0, 0);
display.print(F(“DEBUG v9.3”));
display.drawLine(0, 9, 127, 9, SSD1306_WHITE);

display.setCursor(0, 12);
display.print(F(“Homing: “));
switch(homingPhase) {
case HOMING_NOT_STARTED: display.print(F(“START”)); break;
case HOMING_MOVING: display.print(F(“MOVE”)); break;
case HOMING_COMPLETED: display.print(F(“DONE”)); break;
case HOMING_FAILED: display.print(F(“FAIL”)); break;
}

display.setCursor(0, 22);
display.print(F(“Limit: [”));
display.print(upperLimit ? F(“UP”) : F(”-”));
display.print(F(”][”));
display.print(lowerLimit ? F(“DN”) : F(”-”));
display.print(F(”]”));

display.setCursor(0, 32);
display.print(F(“Lock: “));
display.print(systemLocked ? F(“YES”) : F(“NO”));
display.print(F(”  Auto: “));
if (autoLiftDone) {