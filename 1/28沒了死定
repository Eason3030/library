/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *        æ™ºæ…§è¼”åŠ©è¼ªç³»çµ± - v1.3.6 é™ä½ä¿è­·ç‰ˆ âœ…
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ã€v1.3.6 ä¿®æ­£ã€‘
 * âœ… åŠ å…¥é™ä½è§¸ç™¼æ™‚å¼·åˆ¶åœæ­¢é‚è¼¯
 * âœ… ä¿®æ­£ executeCommand() åœ¨é™ä½æ™‚çš„è¡Œç‚º
 * âœ… ä¿®æ­£ã€Œé–‹ä¸€ä¸‹å°±é—œã€çš„å•é¡Œ
 * 
 * ä½œè€…ï¼šæ—æ©åœ˜éšŠ
 * æ—¥æœŸï¼š2026/01/23
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

#include <Wire.h>
#include <IRremote.hpp>
#include <U8g2lib.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ åƒæ•¸è¨­å®šå€
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const float SPEED_THRESHOLD = 15.0;
const float WHEEL_CIRCUMFERENCE = 2042.0;
const unsigned long HOMING_TIMEOUT = 20000;
const unsigned long MOTOR_CHANGE_DELAY = 500;
const unsigned long IR_DEBOUNCE = 300;
const float SPEED_SMOOTH_ALPHA = 0.3;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”Œ ç¡¬é«”æ¥è…³å®šç¾©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const uint8_t RELAY_PIN = 22;
const uint8_t LIMIT_UP_PIN = 13;
const uint8_t LIMIT_DOWN_PIN = 53;
const uint8_t HALL_SPEED_PIN = 2;
const uint8_t IR_RECEIVE_PIN = 3;
const uint8_t RGB_RED_PIN = 5;
const uint8_t RGB_GREEN_PIN = 6;
const uint8_t RGB_BLUE_PIN = 7;
const uint8_t BUZZER_PIN = 8;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§© è³‡æ–™çµæ§‹å®šç¾©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum Priority {
    P_MANUAL = 0,
    P_SPEED = 1,
    P_IDLE = 2
};

enum IRMode {
    IR_MODE_UP = 0,
    IR_MODE_DOWN = 1,
    IR_MODE_STOP = 2
};

struct Command {
    Priority priority;
    bool wantUp;
    String reason;
    
    Command(Priority p, bool u, String r) 
        : priority(p), wantUp(u), reason(r) {}
    
    Command() : priority(P_IDLE), wantUp(false), reason("å¾…æ©Ÿ") {}
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ å…¨åŸŸè®Šæ•¸
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

volatile unsigned long lastSpeedTrigger = 0;
volatile unsigned long speedInterval = 0;
float currentSpeed = 0;
float smoothSpeed = 0;

Command activeCommand;

bool motorOn = false;
unsigned long lastMotorChange = 0;

IRMode currentIRMode = IR_MODE_UP;
unsigned long lastIRTime = 0;

bool systemReady = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš¡ ä¸­æ–·å‡½å¼ï¼šé€Ÿåº¦æ¸¬é‡
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void speedInterrupt() {
    unsigned long now = micros();
    speedInterval = now - lastSpeedTrigger;
    lastSpeedTrigger = now;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š è¨ˆç®—é€Ÿåº¦
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float calculateSpeed() {
    if (micros() - lastSpeedTrigger > 2000000) {
        smoothSpeed = 0;
        return 0.0;
    }
    
    if (speedInterval == 0) {
        return 0.0;
    }
    
    float rawSpeed = (WHEEL_CIRCUMFERENCE / speedInterval) * 3600.0;
    
    if (rawSpeed > 80.0 || rawSpeed < 0) {
        rawSpeed = 0;
    }
    
    smoothSpeed = SPEED_SMOOTH_ALPHA * rawSpeed + (1 - SPEED_SMOOTH_ALPHA) * smoothSpeed;
    
    return smoothSpeed;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ® æª¢æŸ¥ IR é™æ§
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Command checkManual() {
    if (IrReceiver.decode()) {
        uint32_t code = IrReceiver.decodedIRData.decodedRawData;
        
        if (millis() - lastIRTime > IR_DEBOUNCE) {
            if (code != 0xFFFFFFFF && code != 0) {
                currentIRMode = (IRMode)((currentIRMode + 1) % 3);
                
                switch (currentIRMode) {
                    case IR_MODE_UP:
                        Serial.println("ğŸ”µ IR: åˆ‡æ›åˆ°ã€ä¸Šå‡ã€‘æ¨¡å¼");
                        beep(1500, 100);
                        setRGB(0, 0, 255);
                        break;
                        
                    case IR_MODE_DOWN:
                        Serial.println("ğŸŸ¡ IR: åˆ‡æ›åˆ°ã€ä¸‹é™ã€‘æ¨¡å¼");
                        beep(1000, 100);
                        setRGB(255, 255, 0);
                        break;
                        
                    case IR_MODE_STOP:
                        Serial.println("ğŸŸ¢ IR: åˆ‡æ›åˆ°ã€è‡ªå‹•ã€‘æ¨¡å¼");
                        beep(500, 200);
                        setRGB(0, 255, 0);
                        break;
                }
                
                lastIRTime = millis();
            }
        }
        
        IrReceiver.resume();
    }
    
    switch (currentIRMode) {
        case IR_MODE_UP:
            return Command(P_MANUAL, true, "IRæ‰‹å‹•-ä¸Šå‡");
            
        case IR_MODE_DOWN:
            return Command(P_MANUAL, false, "IRæ‰‹å‹•-ä¸‹é™");
            
        case IR_MODE_STOP:
        default:
            return Command();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸƒ æª¢æŸ¥é€Ÿåº¦
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Command checkSpeed() {
    if (currentSpeed > SPEED_THRESHOLD) {
        return Command(P_SPEED, true, "é€Ÿåº¦å¿«-ä¸Šå‡");
    } else {
        return Command(P_SPEED, false, "é€Ÿåº¦æ…¢-ä¸‹é™");
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ RGB LED æ§åˆ¶
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setRGB(uint8_t r, uint8_t g, uint8_t b) {
    analogWrite(RGB_RED_PIN, r);
    analogWrite(RGB_GREEN_PIN, g);
    analogWrite(RGB_BLUE_PIN, b);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”Š èœ‚é³´å™¨æ§åˆ¶
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void beep(int freq, int duration) {
    tone(BUZZER_PIN, freq, duration);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ–¥ï¸ OLED é¡¯ç¤ºæ›´æ–°
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateDisplay() {
    u8g2.clearBuffer();
    
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 10, "Training Wheel v1.3");
    
    u8g2.setFont(u8g2_font_6x10_tr);
    String modeStr = "IR: ";
    switch (currentIRMode) {
        case IR_MODE_UP:   modeStr += "UP"; break;
        case IR_MODE_DOWN: modeStr += "DOWN"; break;
        case IR_MODE_STOP: modeStr += "AUTO"; break;
    }
    u8g2.drawStr(0, 25, modeStr.c_str());
    
    u8g2.drawStr(0, 38, activeCommand.reason.c_str());
    
    String speedStr = "Spd:" + String(currentSpeed, 1) + " km/h";
    u8g2.drawStr(0, 51, speedStr.c_str());
    
    bool atTop = (digitalRead(LIMIT_UP_PIN) == LOW);
    bool atBottom = (digitalRead(LIMIT_DOWN_PIN) == LOW);
    
    String statusStr = "";
    if (atTop) statusStr += "TOP ";
    if (atBottom) statusStr += "BTM ";
    if (!atTop && !atBottom) statusStr += "MID ";
    statusStr += motorOn ? "[ON]" : "[OFF]";
    
    u8g2.drawStr(0, 64, statusStr.c_str());
    
    u8g2.sendBuffer();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš— é¦¬é”æ§åˆ¶ï¼ˆå¼·åˆ¶ç‰ˆï¼Œç”¨æ–¼åˆå§‹åŒ–ï¼‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void forceMotor(bool on) {
    motorOn = on;
    lastMotorChange = millis();
    digitalWrite(RELAY_PIN, on ? HIGH : LOW);
    
    Serial.print("ğŸ”§ é¦¬é”(å¼·åˆ¶): ");
    Serial.print(on ? "ON (ä¸Šå‡)" : "OFF (ä¸‹é™)");
    Serial.print(" | Pin=");
    Serial.print(digitalRead(RELAY_PIN) == HIGH ? "HIGH" : "LOW");
    Serial.print(" | motorOn=");
    Serial.println(motorOn ? "true" : "false");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš— é¦¬é”æ§åˆ¶ï¼ˆæ­£å¸¸ç‰ˆï¼Œæœ‰å®‰å…¨æª¢æŸ¥ï¼‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setMotor(bool on) {
    // æª¢æŸ¥ 1ï¼šç‹€æ…‹ç›¸åŒä¸å‹•ä½œ
    if (on == motorOn) {
        // âœ… ç§»é™¤ Serial è¼¸å‡ºï¼Œé¿å…åˆ·å±
        return;
    }
    
    // æª¢æŸ¥ 2ï¼šé˜²æ­¢é »ç¹åˆ‡æ›
    unsigned long timeSinceChange = millis() - lastMotorChange;
    if (timeSinceChange < MOTOR_CHANGE_DELAY) {
        Serial.print("â¸ï¸ è·é›¢ä¸Šæ¬¡åˆ‡æ›åƒ… ");
        Serial.print(timeSinceChange);
        Serial.println("msï¼Œè·³é (éœ€è¦ >= 500ms)");
        return;
    }
    
    motorOn = on;
    lastMotorChange = millis();
    digitalWrite(RELAY_PIN, on ? HIGH : LOW);
    
    if (currentIRMode == IR_MODE_STOP) {
        if (on) {
            setRGB(0, 0, 255);
        } else {
            setRGB(255, 255, 0);
        }
    }
    
    Serial.print("ğŸ”§ é¦¬é”: ");
    Serial.print(on ? "ON (ä¸Šå‡)" : "OFF (ä¸‹é™)");
    Serial.print(" | Pin=");
    Serial.print(digitalRead(RELAY_PIN) == HIGH ? "HIGH" : "LOW");
    Serial.print(" | motorOn=");
    Serial.println(motorOn ? "true" : "false");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ åŸ·è¡ŒæŒ‡ä»¤ï¼ˆv1.3.6 ä¿®æ­£ç‰ˆï¼‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void executeCommand(Command cmd) {
    bool atTop = (digitalRead(LIMIT_UP_PIN) == LOW);
    bool atBottom = (digitalRead(LIMIT_DOWN_PIN) == LOW);
    
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint > 1000) {
        Serial.print("ğŸ“ ä½ç½®: ");
        if (atTop) Serial.print("ä¸Šé™ ");
        if (atBottom) Serial.print("ä¸‹é™ ");
        if (!atTop && !atBottom) Serial.print("ä¸­é–“ ");
        Serial.print("| æŒ‡ä»¤: ");
        Serial.print(cmd.wantUp ? "ä¸Šå‡" : "ä¸‹é™");
        Serial.print(" (");
        Serial.print(cmd.reason);
        Serial.println(")");
        lastPrint = millis();
    }
    
    // âœ… é—œéµä¿®æ”¹ 1ï¼šä¸Šé™è§¸ç™¼æ™‚ï¼Œå¼·åˆ¶åœæ­¢
    if (atTop) {
        if (motorOn) {
            Serial.println("ğŸ›‘ ä¸Šé™è§¸ç™¼ï¼å¼·åˆ¶åœæ­¢ä¸Šå‡");
            setMotor(false);
            beep(2000, 100);
        }
        return;  // åœ¨ä¸Šé™æ™‚ï¼Œä¸åŸ·è¡Œä»»ä½•æŒ‡ä»¤
    }
    
    // âœ… é—œéµä¿®æ”¹ 2ï¼šä¸‹é™æ™‚ï¼Œåªå…è¨±ä¸Šå‡
    if (atBottom) {
        if (!cmd.wantUp) {
            // æƒ³ä¸‹é™ï¼Œä½†å·²åœ¨ä¸‹é™ â†’ å¿½ç•¥
            return;
        }
        // æƒ³ä¸Šå‡ â†’ ç¹¼çºŒåŸ·è¡Œ
    }
    
    // å¾…æ©Ÿç‹€æ…‹
    if (cmd.priority == P_IDLE) {
        return;
    }
    
    // âœ… åŸ·è¡ŒæŒ‡ä»¤
    if (cmd.wantUp) {
        setMotor(true);
    } else {
        setMotor(false);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ è‡ªå‹•æ­¸é›¶
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void autoHoming() {
    Serial.println("\n========== ğŸ é–‹å§‹æ­¸é›¶ ==========");
    
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 25, "Homing...");
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(0, 40, "Checking position");
    u8g2.sendBuffer();
    
    bool atTop = (digitalRead(LIMIT_UP_PIN) == LOW);
    bool atBottom = (digitalRead(LIMIT_DOWN_PIN) == LOW);
    
    Serial.print("ğŸ” åˆå§‹ä½ç½®: ");
    if (atTop) Serial.print("ä¸Šé™ ");
    if (atBottom) Serial.print("ä¸‹é™ ");
    if (!atTop && !atBottom) Serial.print("ä¸­é–“ ");
    Serial.println();
    
    if (atBottom) {
        Serial.println("âœ… å·²åœ¨ä¸‹é™ï¼Œç„¡éœ€æ­¸é›¶ï¼");
        
        currentIRMode = IR_MODE_UP;
        
        beep(1500, 200);
        setRGB(0, 0, 255);
        
        u8g2.clearBuffer();
        u8g2.setFont(u8g2_font_ncenB08_tr);
        u8g2.drawStr(0, 20, "System Ready!");
        u8g2.setFont(u8g2_font_6x10_tr);
        u8g2.drawStr(0, 35, "Mode: UP");
        u8g2.drawStr(0, 50, "Ready to rise!");
        u8g2.sendBuffer();
        
        delay(2000);
        systemReady = true;
        
        Serial.println("ğŸ”µ ç³»çµ±å•Ÿå‹•æ–¼ã€ä¸Šå‡ã€‘æ¨¡å¼");
        return;
    }
    
    Serial.println("ğŸ“ ä¸åœ¨ä¸‹é™ï¼Œé–‹å§‹æ­¸é›¶ç¨‹åº...");
    
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 25, "Homing...");
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(0, 40, "Moving to bottom");
    u8g2.sendBuffer();
    
    forceMotor(false);
    
    Serial.println("â³ ç­‰å¾…è‡´å‹•å™¨é–‹å§‹å‹•ä½œï¼ˆ500msï¼‰...");
    delay(500);
    
    unsigned long startTime = millis();
    bool ledState = false;
    unsigned long lastStatusPrint = 0;
    
    Serial.println("ğŸ”„ æŒçºŒä¸‹é™ä¸­ï¼Œç­‰å¾…è§¸ç™¼ä¸‹é™...");
    
    while (digitalRead(LIMIT_DOWN_PIN) == HIGH) {
        if (millis() - startTime > HOMING_TIMEOUT) {
            Serial.println("âŒ æ­¸é›¶è¶…æ™‚ï¼");
            
            u8g2.clearBuffer();
            u8g2.setFont(u8g2_font_ncenB08_tr);
            u8g2.drawStr(0, 30, "ERROR:");
            u8g2.drawStr(0, 45, "Homing timeout!");
            u8g2.sendBuffer();
            
            for (int i = 0; i < 5; i++) {
                setRGB(255, 0, 0);
                beep(1000, 200);
                delay(200);
                setRGB(0, 0, 0);
                delay(200);
            }
            
            while(1);
        }
        
        if (millis() - lastStatusPrint > 1000) {
            Serial.print("  ç­‰å¾…ä¸­... ");
            Serial.print((millis() - startTime) / 1000);
            Serial.println("s");
            lastStatusPrint = millis();
        }
        
        ledState = !ledState;
        setRGB(ledState ? 255 : 0, 0, 0);
        delay(100);
    }
    
    Serial.println("âœ… ä¸‹é™è§¸ç™¼ï¼æ­¸é›¶å®Œæˆï¼");
    
    currentIRMode = IR_MODE_UP;
    
    beep(1500, 200);
    setRGB(0, 0, 255);
    
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 20, "System Ready!");
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(0, 35, "Mode: UP");
    u8g2.drawStr(0, 50, "Ready to rise!");
    u8g2.sendBuffer();
    
    delay(2000);
    systemReady = true;
    
    Serial.println("ğŸ”µ ç³»çµ±å•Ÿå‹•æ–¼ã€ä¸Šå‡ã€‘æ¨¡å¼");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ Setup
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setup() {
    Serial.begin(115200);
    Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Serial.println("â•‘   æ™ºæ…§è¼”åŠ©è¼ªç³»çµ± v1.3.6 é™ä½ä¿è­·ç‰ˆ     â•‘");
    Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    Wire.begin();
    
    u8g2.begin();
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 30, "Initializing...");
    u8g2.sendBuffer();
    delay(500);
    Serial.println("âœ“ OLED é¡¯ç¤ºå™¨å°±ç·’");
    
    IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
    Serial.println("âœ“ IR æ¥æ”¶å™¨å°±ç·’");
    
    pinMode(RELAY_PIN, OUTPUT);
    pinMode(LIMIT_UP_PIN, INPUT_PULLUP);
    pinMode(LIMIT_DOWN_PIN, INPUT_PULLUP);
    pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
    pinMode(RGB_RED_PIN, OUTPUT);
    pinMode(RGB_GREEN_PIN, OUTPUT);
    pinMode(RGB_BLUE_PIN, OUTPUT);
    pinMode(BUZZER_PIN, OUTPUT);
    Serial.println("âœ“ GPIO è…³ä½è¨­å®šå®Œæˆ");
    
    delay(100);
    
    digitalWrite(RELAY_PIN, HIGH);
    motorOn = true;
    lastMotorChange = millis();
    Serial.println("âœ“ é¦¬é”åˆå§‹åŒ–ï¼ˆON - æº–å‚™ä¸Šå‡ï¼‰");
    
    attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
    Serial.println("âœ“ éœçˆ¾æ„Ÿæ¸¬å™¨ä¸­æ–·å•Ÿå‹•");
    
    beep(1000, 100);
    delay(100);
    beep(1500, 100);
    delay(500);
    
    autoHoming();
    
    Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Serial.println("â•‘          ç³»çµ±å°±ç·’ï¼é–‹å§‹é‹ä½œ            â•‘");
    Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ Loopï¼ˆv1.3.6 åŠ å…¥é™ä½ä¿è­·ï¼‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loop() {
    // âœ… é—œéµä¿®æ”¹ï¼šåœ¨ loop é–‹é ­æª¢æŸ¥é™ä½ï¼ˆæœ€é«˜å„ªå…ˆç´šï¼‰
    bool atTop = (digitalRead(LIMIT_UP_PIN) == LOW);
    bool atBottom = (digitalRead(LIMIT_DOWN_PIN) == LOW);
    
    // ä¸Šé™ä¿è­·ï¼šå¦‚æœåœ¨ä¸Šé™ä¸”é¦¬é”é‚„åœ¨è½‰ï¼Œå¼·åˆ¶åœæ­¢
    if (atTop && motorOn) {
        Serial.println("ğŸš¨ ç·Šæ€¥åœæ­¢ï¼šä¸Šé™è§¸ç™¼ï¼");
        forceMotor(false);  // ä½¿ç”¨ forceMotor ç«‹å³åœæ­¢
        beep(2000, 200);
    }
    
    currentSpeed = calculateSpeed();
    
    Command manual = checkManual();
    Command speed = checkSpeed();
    
    if (manual.priority < speed.priority) {
        activeCommand = manual;
    } else {
        activeCommand = speed;
    }
    
    executeCommand(activeCommand);
    
    updateDisplay();
    
    delay(50);
}
