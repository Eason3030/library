// ============================================================================
// 智能輔助輪控制系統 v9.0 - 極簡可靠版
// ============================================================================
// 設計理念：高職生也能看懂、改不壞
// 
// 核心功能：
// 1. 速度持續 2 秒 ≥ 15 km/h → 自動上升
// 2. 磁簧開關絕對優先（不可被中斷）
// 3. 單馬達控制（只能 ON/OFF）
// 4. 安全測試模式
// 
// 移除功能：
// - IMU 傾斜感測（太複雜，容易出錯）
// - 多重鎖機制（統一成單一鎖）
// - 複雜的 OLED 頁面（只保留 2 頁）
// ============================================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <avr/wdt.h>

// ============================================================================
// OLED 設定
// ============================================================================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ============================================================================
// 音符定義
// ============================================================================
#define NOTE_C4  262
#define NOTE_E4  330
#define NOTE_G4  392
#define NOTE_C5  523
#define NOTE_A5  880
#define NOTE_C6  1047

// ============================================================================
// MPU6050 設定（簡化版）
// ============================================================================
#define MPU_ADDR 0x69
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B

// ============================================================================
// 腳位定義
// ============================================================================
const byte BUZZER_PIN = 8;
const byte IR_RECEIVE_PIN = 3;
const byte PWM_PIN = 9;

// 磁簧開關（常開型，LOW = 觸發）
const byte LIMIT_UP_PIN = 52;
const byte LIMIT_DOWN_PIN = 53;

// 速度感測
const byte HALL_SPEED_PIN = 2;
const byte SPEED_CONTROL_PIN = A0;

// RGB LED
const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;

// ============================================================================
// 系統狀態（簡化成 4 個，知道方向）
// ============================================================================
enum SystemState : byte {
  AT_TOP,      // 停在上限位
  AT_BOTTOM,   // 停在下限位
  MOVING_UP,   // 正在上升
  MOVING_DOWN  // 正在下降（手動）
};

// ============================================================================
// 全域變數
// ============================================================================
SystemState currentState = AT_BOTTOM;  // 開機預設在下方（最安全）

// 限位開關
bool upperLimit = false;
bool lowerLimit = false;
unsigned long lastLimitCheck = 0;
const unsigned long LIMIT_DEBOUNCE = 50;

// 系統鎖（統一管理）
bool systemLocked = false;
unsigned long lockStartTime = 0;
const unsigned long LOCK_DURATION = 500;  // 統一 500ms

// PWM 控制
int pwmSpeed = 200;
unsigned long lastSpeedRead = 0;

// 速度測量
#define WHEEL_CIRCUMFERENCE 204.2
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t speedPulseInterval = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
unsigned long lastSpeedUpdate = 0;
const unsigned long SPEED_TIMEOUT = 2000;

// 【核心功能】自動上升邏輯
const float AUTO_LIFT_SPEED = 15.0;        // 速度門檻
const unsigned long SPEED_HOLD_TIME = 2000; // 持續 2 秒
unsigned long speedAboveThresholdTime = 0;  // 開始計時的時間
bool speedTimerRunning = false;             // 計時器是否啟動
bool autoLiftDone = false;                  // 本次是否已執行過

// IR 控制
unsigned long lastIRTime = 0;
const unsigned long IR_DELAY = 500;

// OLED 顯示（2 頁）
bool showDebugPage = false;
unsigned long lastDisplayUpdate = 0;

// 序列埠輸出
unsigned long lastSerialPrint = 0;

// 測試模式（讓你可以安全測試）
bool testMode = false;

// IMU 資料（簡化版）
float tiltAngle = 0.0;
unsigned long lastIMURead = 0;
const unsigned long IMU_READ_INTERVAL = 100;  // 每 100ms 讀一次
const float TILT_WARNING = 10.0;              // 10 度警告
const float TILT_DANGER = 15.0;               // 15 度危險
bool lastTiltWarning = false;

// ============================================================================
// 速度中斷（獨立測量，不干擾主邏輯）
// ============================================================================
void speedInterrupt() {
  uint32_t now = micros();
  uint32_t interval = now - lastSpeedTrigger;
  
  // 防抖動（40ms）
  if (interval > 40000) {
    speedPulseInterval = interval;
    lastSpeedTrigger = now;
    newSpeedData = true;
  }
}

// ============================================================================
// RGB LED（簡化成 3 色）
// ============================================================================
void setRGB(byte r, byte g, byte b) {
  analogWrite(RGB_RED_PIN, r);
  analogWrite(RGB_GREEN_PIN, g);
  analogWrite(RGB_BLUE_PIN, b);
}

void updateRGBByState() {
  switch(currentState) {
    case AT_TOP:
      setRGB(0, 255, 255);  // 青色
      break;
    case AT_BOTTOM:
      setRGB(255, 200, 0);  // 黃色
      break;
    case MOVING_UP:
      setRGB(0, 255, 0);    // 綠色（上升中）
      break;
    case MOVING_DOWN:
      setRGB(255, 0, 0);    // 紅色（下降中）
      break;
  }
}

// ============================================================================
// 音效（簡化）
// ============================================================================
void playStartupMusic() {
  tone(BUZZER_PIN, NOTE_C4, 150); delay(180);
  tone(BUZZER_PIN, NOTE_E4, 150); delay(180);
  tone(BUZZER_PIN, NOTE_G4, 150); delay(180);
  tone(BUZZER_PIN, NOTE_C5, 300); delay(350);
  noTone(BUZZER_PIN);
}

void playBeep(uint16_t freq, uint16_t duration) {
  tone(BUZZER_PIN, freq, duration);
  delay(duration + 20);
  noTone(BUZZER_PIN);
}

void playWarning() {
  for(int i = 0; i < 3; i++) {
    tone(BUZZER_PIN, NOTE_C6, 100);
    delay(150);
  }
  noTone(BUZZER_PIN);
}

// ============================================================================
// IMU 簡化版（只讀角度）
// ============================================================================
void setupIMU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(PWR_MGMT_1);
  Wire.write(0x00);  // 喚醒 MPU
  byte error = Wire.endTransmission();
  
  if (error == 0) {
    Serial.println(F("IMU 初始化成功"));
  } else {
    Serial.println(F("IMU 初始化失敗"));
  }
  delay(50);
}

void readIMU() {
  if (millis() - lastIMURead < IMU_READ_INTERVAL) {
    return;  // 還沒到時間
  }
  lastIMURead = millis();
  
  // 讀取加速度計（只讀 X 和 Z）
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(ACCEL_XOUT_H);
  byte error = Wire.endTransmission(false);
  
  if (error != 0) {
    tiltAngle = 0.0;  // 讀取失敗，歸零
    return;
  }
  
  Wire.requestFrom((byte)MPU_ADDR, (byte)4);
  if (Wire.available() >= 4) {
    int16_t ax = (Wire.read() << 8) | Wire.read();
    int16_t ay = (Wire.read() << 8) | Wire.read();  // 先讀 Y（雖然不用）
    
    // 再讀 Z
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(ACCEL_XOUT_H + 4);
    Wire.endTransmission(false);
    Wire.requestFrom((byte)MPU_ADDR, (byte)2);
    int16_t az = (Wire.read() << 8) | Wire.read();
    
    // 轉換成 g 值
    float accelX = ax / 16384.0;
    float accelZ = az / 16384.0;
    
    // 計算傾斜角度（簡單版）
    tiltAngle = atan2(accelX, accelZ) * 57.2958;  // 轉換成度
    
    // 限制範圍
    if (tiltAngle > 90) tiltAngle = 90;
    if (tiltAngle < -90) tiltAngle = -90;
  }
}

void checkTiltWarning() {
  float absTilt = abs(tiltAngle);
  bool currentWarning = (absTilt >= TILT_WARNING);
  
  // 只在剛超過門檻時叫一次
  if (currentWarning && !lastTiltWarning) {
    if (absTilt >= TILT_DANGER) {
      // 危險等級 - 長叫
      playWarning();
      Serial.print(F("[警告] 危險傾斜: "));
      Serial.println(tiltAngle, 1);
    } else {
      // 警告等級 - 短叫
      tone(BUZZER_PIN, NOTE_A5, 200);
      delay(220);
      noTone(BUZZER_PIN);
      Serial.print(F("[警告] 傾斜警告: "));
      Serial.println(tiltAngle, 1);
    }
  }
  
  lastTiltWarning = currentWarning;
}

// ============================================================================
// 速度計算
// ============================================================================
void updateSpeed() {
  if (newSpeedData) {
    if (speedPulseInterval > 0) {
      float timeInSec = speedPulseInterval / 1000000.0;
      currentSpeed = (WHEEL_CIRCUMFERENCE / timeInSec) * 0.036;
    }
    newSpeedData = false;
    lastSpeedUpdate = millis();
  }
  
  // 超時判斷（2秒無訊號 = 靜止）
  if (millis() - lastSpeedUpdate > SPEED_TIMEOUT) {
    currentSpeed = 0.0;
  }
}

// ============================================================================
// 【核心安全】限位開關檢查（最高優先權）
// ============================================================================
void checkLimitSwitches() {
  // 去抖動
  if (millis() - lastLimitCheck < LIMIT_DEBOUNCE) {
    return;
  }
  lastLimitCheck = millis();
  
  // 讀取原始值
  bool upperRaw = (digitalRead(LIMIT_UP_PIN) == LOW);
  bool lowerRaw = (digitalRead(LIMIT_DOWN_PIN) == LOW);
  
  // 【關鍵安全邏輯】只處理單一觸發
  if (upperRaw && !lowerRaw) {
    // 觸發上限位
    analogWrite(PWM_PIN, 0);
    currentState = AT_TOP;
    systemLocked = true;
    lockStartTime = millis();
    upperLimit = true;
    lowerLimit = false;
    
    // 重置自動上升
    autoLiftDone = false;
    speedTimerRunning = false;
    
    Serial.println(F("[限位] 到達上方"));
    
  } else if (lowerRaw && !upperRaw) {
    // 觸發下限位
    analogWrite(PWM_PIN, 0);
    currentState = AT_BOTTOM;
    systemLocked = true;
    lockStartTime = millis();
    upperLimit = false;
    lowerLimit = true;
    
    Serial.println(F("[限位] 到達下方"));
    
  } else if (upperRaw && lowerRaw) {
    // 異常：兩個都觸發
    analogWrite(PWM_PIN, 0);
    currentState = AT_TOP;
    systemLocked = true;
    lockStartTime = millis();
    
    Serial.println(F("[錯誤] 雙限位觸發!"));
    playWarning();
    
  } else {
    // 都沒觸發
    upperLimit = false;
    lowerLimit = false;
  }
}

// ============================================================================
// 馬達控制
// ============================================================================
void startMotorUp() {
  if (systemLocked) {
    Serial.println(F("[控制] 系統鎖定中"));
    return;
  }
  
  if (currentState == MOVING_UP) {
    Serial.println(F("[控制] 已在上升中"));
    return;
  }
  
  if (currentState == AT_TOP) {
    Serial.println(F("[控制] 已在頂端"));
    return;
  }
  
  // 啟動馬達
  analogWrite(PWM_PIN, pwmSpeed);
  currentState = MOVING_UP;
  systemLocked = true;
  lockStartTime = millis();
  
  playBeep(NOTE_A5, 100);
  Serial.println(F("[馬達] 開始上升"));
}

void startMotorDown() {
  if (systemLocked) {
    Serial.println(F("[控制] 系統鎖定中"));
    return;
  }
  
  if (currentState == MOVING_DOWN) {
    Serial.println(F("[控制] 已在下降中"));
    return;
  }
  
  if (currentState == AT_BOTTOM) {
    Serial.println(F("[控制] 已在底部"));
    return;
  }
  
  // 啟動馬達
  analogWrite(PWM_PIN, pwmSpeed);
  currentState = MOVING_DOWN;
  systemLocked = true;
  lockStartTime = millis();
  
  playBeep(NOTE_A5, 100);
  Serial.println(F("[馬達] 開始下降"));
}

void stopMotor() {
  analogWrite(PWM_PIN, 0);
  Serial.println(F("[馬達] 停止"));
}

// ============================================================================
// 【核心功能】自動上升邏輯
// ============================================================================
void checkAutoLift() {
  // 只有在底部才能觸發
  if (currentState != AT_BOTTOM) {
    speedTimerRunning = false;
    speedAboveThresholdTime = 0;
    return;
  }
  
  // 如果本次已經執行過，不再重複
  if (autoLiftDone) {
    return;
  }
  
  // 檢查速度是否達標
  if (currentSpeed >= AUTO_LIFT_SPEED) {
    // 速度達標
    if (!speedTimerRunning) {
      // 第一次達標，開始計時
      speedTimerRunning = true;
      speedAboveThresholdTime = millis();
      Serial.println(F("[自動] 速度達標，開始計時"));
    } else {
      // 已經在計時，檢查是否持續 2 秒
      unsigned long elapsed = millis() - speedAboveThresholdTime;
      if (elapsed >= SPEED_HOLD_TIME) {
        // 持續 2 秒，執行上升
        Serial.println(F("[自動] 持續 2 秒，開始上升!"));
        startMotorUp();
        autoLiftDone = true;  // 標記已執行
        speedTimerRunning = false;
        playBeep(NOTE_C5, 200);
      }
    }
  } else {
    // 速度未達標，重置計時器
    if (speedTimerRunning) {
      Serial.println(F("[自動] 速度下降，重置計時"));
    }
    speedTimerRunning = false;
    speedAboveThresholdTime = 0;
  }
}

// ============================================================================
// IR 控制
// ============================================================================
void handleIR(uint32_t code) {
  if (millis() - lastIRTime < IR_DELAY) return;
  lastIRTime = millis();
  
  switch(code) {
    case 0xFF18E7:  // 上鍵
    case 0x1:
      Serial.println(F("[IR] 手動上升"));
      startMotorUp();
      break;
      
    case 0xFF4AB5:  // 下鍵
    case 0x2:
      Serial.println(F("[IR] 手動下降"));
      startMotorDown();
      break;
      
    case 0xFF38C7:  // OK 鍵 - 切換頁面
    case 0x3:
      showDebugPage = !showDebugPage;
      playBeep(NOTE_A5, 50);
      Serial.print(F("[OLED] 切換到 "));
      Serial.println(showDebugPage ? F("除錯頁") : F("主頁"));
      break;
      
    case 0xFF30CF:  // * 鍵 - 測試模式
    case 0x4:
      testMode = !testMode;
      playBeep(NOTE_C6, 100);
      Serial.print(F("[測試] 測試模式 "));
      Serial.println(testMode ? F("ON") : F("OFF"));
      break;
      
    default:
      Serial.print(F("[IR] 未知碼: 0x"));
      Serial.println(code, HEX);
      break;
  }
}

// ============================================================================
// OLED 顯示（2 頁）
// ============================================================================
void drawMainPage() {
  display.clearDisplay();
  
  // 標題
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print(F("WHEEL v9.0"));
  
  if (testMode) {
    display.setCursor(90, 0);
    display.print(F("TEST"));
  }
  
  display.drawLine(0, 9, 127, 9, SSD1306_WHITE);
  
  // 狀態（大字）
  display.setTextSize(2);
  display.setCursor(0, 12);
  switch(currentState) {
    case AT_TOP:
      display.print(F("AT TOP"));
      break;
    case AT_BOTTOM:
      display.print(F("BOTTOM"));
      break;
    case MOVING_UP:
      display.print(F("UP"));
      break;
    case MOVING_DOWN:
      display.print(F("DOWN"));
      break;
  }
  
  display.drawLine(0, 28, 127, 28, SSD1306_WHITE);
  
  // 速度 + 角度（並排）
  display.setTextSize(1);
  display.setCursor(0, 31);
  display.print(F("Speed:"));
  
  display.setTextSize(2);
  display.setCursor(0, 40);
  int speedInt = (int)currentSpeed;
  if (speedInt < 10) display.print(F(" "));
  display.print(speedInt);
  
  display.setTextSize(1);
  display.setCursor(30, 44);
  display.print(F("km/h"));
  
  // 角度
  display.setCursor(70, 31);
  display.print(F("Angle:"));
  
  display.setTextSize(2);
  display.setCursor(70, 40);
  int angleInt = (int)tiltAngle;
  if (angleInt >= 0 && angleInt < 10) display.print(F(" "));
  display.print(angleInt);
  
  display.setTextSize(1);
  display.setCursor(100, 44);
  display.print((char)247);  // 度符號
  
  // 警告指示
  if (abs(tiltAngle) >= TILT_DANGER) {
    display.fillRect(110, 31, 18, 10, SSD1306_WHITE);
    display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    display.setCursor(112, 32);
    display.print(F("!!"));
    display.setTextColor(SSD1306_WHITE);
  } else if (abs(tiltAngle) >= TILT_WARNING) {
    display.setCursor(112, 32);
    display.print(F("!"));
  }
  
  display.drawLine(0, 52, 127, 52, SSD1306_WHITE);
  
  // 自動上升指示 + PWM
  display.setCursor(0, 54);
  display.print(F("PWM:"));
  display.print(pwmSpeed);
  
  if (speedTimerRunning) {
    unsigned long elapsed = millis() - speedAboveThresholdTime;
    unsigned long remaining = (SPEED_HOLD_TIME - elapsed) / 100;
    
    display.setCursor(60, 54);
    display.print(F("AUTO:"));
    display.print(remaining / 10);
    display.print(F("."));
    display.print(remaining % 10);
  }
  
  display.display();
}

void drawDebugPage() {
  display.clearDisplay();
  
  // 標題
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print(F("DEBUG"));
  
  display.drawLine(0, 9, 127, 9, SSD1306_WHITE);
  
  // 限位開關狀態
  display.setCursor(0, 12);
  display.print(F("Limit: ["));
  display.print(upperLimit ? F("U") : F("-"));
  display.print(F("]["));
  display.print(lowerLimit ? F("D") : F("-"));
  display.print(F("]"));
  
  // 系統鎖
  display.setCursor(0, 22);
  display.print(F("Lock: "));
  display.print(systemLocked ? F("YES") : F("NO"));
  
  // 自動上升狀態
  display.setCursor(0, 32);
  display.print(F("Auto: "));
  if (autoLiftDone) {
    display.print(F("DONE"));
  } else if (speedTimerRunning) {
    display.print(F("TIMING"));
  } else {
    display.print(F("READY"));
  }
  
  // 速度詳細
  display.setCursor(0, 42);
  display.print(F("Speed: "));
  display.print(currentSpeed, 1);
  display.print(F(" km/h"));
  
  // 角度詳細
  display.setCursor(0, 52);
  display.print(F("Tilt:  "));
  display.print(tiltAngle, 1);
  display.print((char)247);
  
  if (abs(tiltAngle) >= TILT_DANGER) {
    display.print(F(" DANGER"));
  } else if (abs(tiltAngle) >= TILT_WARNING) {
    display.print(F(" WARN"));
  }
  
  display.display();
}

void updateDisplay() {
  if (millis() - lastDisplayUpdate < 250) return;
  lastDisplayUpdate = millis();
  
  if (showDebugPage) {
    drawDebugPage();
  } else {
    drawMainPage();
  }
}

// ============================================================================
// Setup
// ============================================================================
void setup() {
  wdt_disable();
  Serial.begin(115200);
  delay(100);
  
  // 腳位初始化
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(PWM_PIN, OUTPUT);
  pinMode(LIMIT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_DOWN_PIN, INPUT_PULLUP);
  pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
  pinMode(SPEED_CONTROL_PIN, INPUT);
  pinMode(RGB_RED_PIN, OUTPUT);
  pinMode(RGB_GREEN_PIN, OUTPUT);
  pinMode(RGB_BLUE_PIN, OUTPUT);
  
  // 確保馬達停止
  analogWrite(PWM_PIN, 0);
  setRGB(0, 0, 0);
  
  // 中斷與外設
  attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  
  // OLED
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("OLED 初始化失敗!"));
    while(1);
  }
  
  // 開機畫面
  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(10, 10);
  display.print(F("WHEEL"));
  display.setTextSize(1);
  display.setCursor(10, 35);
  display.print(F("v9.0 Simple"));
  display.display();
  delay(1500);
  
  playStartupMusic();
  
  // IMU 初始化
  setupIMU();
  
  Serial.println(F("===================================="));
  Serial.println(F("  智能輔助輪 v9.0 極簡版"));
  Serial.println(F("===================================="));
  Serial.println(F("\n【核心功能】"));
  Serial.println(F("✓ 速度持續 2 秒 ≥ 15 km/h → 自動上升"));
  Serial.println(F("✓ 限位開關絕對優先"));
  Serial.println(F("✓ 傾斜 > 10° 警告 / > 15° 危險"));
  Serial.println(F("✓ 單一鎖機制"));
  Serial.println(F("✓ 2 頁 OLED（主頁/除錯）"));
  Serial.println(F("===================================="));
  Serial.println(F("\n【IR 按鍵】"));
  Serial.println(F("上鍵 → 手動上升"));
  Serial.println(F("下鍵 → 手動下降"));
  Serial.println(F("OK 鍵 → 切換頁面"));
  Serial.println(F("* 鍵 → 測試模式（停用自動上升）"));
  Serial.println(F("====================================\n"));
  
  wdt_enable(WDTO_2S);
}

// ============================================================================
// Loop 主迴圈（清晰的執行順序）
// ============================================================================
void loop() {
  wdt_reset();
  
  // ========== 第一優先：安全檢查 ==========
  checkLimitSwitches();
  
  // 如果限位觸發，跳過所有邏輯
  if (upperLimit || lowerLimit) {
    updateDisplay();
    updateRGBByState();
    delay(10);
    return;
  }
  
  // ========== 第二優先：更新資料 ==========
  updateSpeed();
  readIMU();  // 讀取傾斜角度;
  
  // 讀取 PWM 設定
  if (millis() - lastSpeedRead > 100) {
    lastSpeedRead = millis();
    int raw = analogRead(SPEED_CONTROL_PIN);
    pwmSpeed = map(raw, 0, 1023, 100, 255);
    pwmSpeed = constrain(pwmSpeed, 100, 255);
  }
  
  // ========== 第三優先：解鎖檢查 ==========
  if (systemLocked && millis() - lockStartTime > LOCK_DURATION) {
    systemLocked = false;
    Serial.println(F("[系統] 解鎖"));
  }
  
  // ========== 第四優先：自動上升（只在非測試模式） ==========
  if (!testMode) {
    checkAutoLift();
  }
  
  // ========== 第五優先：IR 控制 ==========
  if (IrReceiver.decode()) {
    handleIR(IrReceiver.decodedIRData.decodedRawData);
    IrReceiver.resume();
  }
  
  // ========== 第六優先：傾斜警告 ==========
  checkTiltWarning();
  
  // ========== 介面更新 ==========
  updateDisplay();
  updateRGBByState();
  
  // ========== 序列埠輸出（每秒一次） ==========
  if (millis() - lastSerialPrint > 1000) {
    lastSerialPrint = millis();
    
    Serial.print(F("狀態:"));
    switch(currentState) {
      case AT_TOP: Serial.print(F("上")); break;
      case AT_BOTTOM: Serial.print(F("下")); break;
      case MOVING_UP: Serial.print(F("↑")); break;
      case MOVING_DOWN: Serial.print(F("↓")); break;
    }
    
    Serial.print(F(" |限位:["));
    Serial.print(upperLimit ? F("上") : F("-"));
    Serial.print(F("]["));
    Serial.print(lowerLimit ? F("下") : F("-"));
    Serial.print(F("]"));
    
    Serial.print(F(" |速度:"));
    Serial.print(currentSpeed, 1);
    Serial.print(F("km/h"));
    
    Serial.print(F(" |角度:"));
    Serial.print(tiltAngle, 1);
    Serial.print((char)176);  // 度符號;
    
    if (speedTimerRunning) {
      unsigned long elapsed = millis() - speedAboveThresholdTime;
      Serial.print(F(" |計時:"));
      Serial.print(elapsed / 100);
      Serial.print(F("/20"));
    }
    
    Serial.print(F(" |鎖:"));
    Serial.print(systemLocked ? F("是") : F("否"));
    
    if (testMode) {
      Serial.print(F(" |測試模式"));
    }
    
    Serial.println();
  }
  
  delay(5);
}
