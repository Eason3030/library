// ============================================================================
// 自行車輔助輪智能控制系統 v5.0 - 自動往返馬達版
// 
// 【主要更新】
// ✅ 支援自動往返型線性制動器（通電/斷電控制）
// ✅ 四個磁簧開關同步限位監控
// ✅ 飛機起降式速度控制 (20km/h UP, 15km/h DOWN)
// ✅ 馬達相位追蹤與方向管理
// ✅ 手動重置機制（移除自動恢復）
// ✅ 完整診斷模式
// ============================================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <INA226_WE.h>
#include <avr/wdt.h>

// ============================================================================
// OLED 螢幕設定
// ============================================================================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ============================================================================
// 系統設定
// ============================================================================
const bool BUTTON_IS_NC_TYPE = true;
const bool IGNORE_CURRENT_SENSOR = false;  // 建議啟用電流保護
const bool ENABLE_DIAGNOSTICS = false;     // 設為 true 啟動診斷模式

// ============================================================================
// 音符定義
// ============================================================================
#define NOTE_C5  523
#define NOTE_E5  659
#define NOTE_G5  784
#define NOTE_C6  1047
#define NOTE_A5  880

// ============================================================================
// MPU6050 設定
// ============================================================================
#define MPU_6050 0x69
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B
#define GYRO_XOUT_H  0x43

// ============================================================================
// 腳位定義
// ============================================================================
const byte BUZZER_PIN = 8;
const byte MOTOR_POWER_PIN = 11;  // 馬達通電控制（原 RELAY_PIN）
const byte IR_RECEIVE_PIN = 3;

// 四個磁簧開關腳位
const byte LIMIT_LEFT_UP_PIN = 4;
const byte LIMIT_LEFT_DOWN_PIN = 10;
const byte LIMIT_RIGHT_UP_PIN = 13;
const byte LIMIT_RIGHT_DOWN_PIN = A1;

const byte HALL_SPEED_PIN = 2;
const byte EMERGENCY_STOP_PIN = 12;
const byte RESET_BUTTON_PIN = A2;  // 新增：手動重置按鈕
const byte SPEED_POT_PIN = A0;     // 保留但不用於速度調整

const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;
const bool RGB_COMMON_ANODE = false;

// ============================================================================
// 狀態定義
// ============================================================================

enum MotionState : byte {
  IDLE,
  MOVING_UP,
  MOVING_DOWN,
  WAITING_REVERSE  // 新增：等待馬達換向
};

enum MotorPhase : byte {
  PHASE_UNKNOWN,
  PHASE_EXTENDING,    // 正在伸出（放下）
  PHASE_RETRACTING,   // 正在縮回（收起）
  PHASE_AT_DOWN,      // 已在下限
  PHASE_AT_UP         // 已在上限
};

enum ControlPriority : byte {
  PRIORITY_EMERGENCY = 0,
  PRIORITY_SAFETY_DOWN = 1,
  PRIORITY_COOLING = 2,
  PRIORITY_MANUAL = 3,
  PRIORITY_AUTO = 4
};

enum SystemState : byte {
  RUNNING,
  COOLING_DOWN,
  EMERGENCY,
  DIAGNOSTICS  // 新增：診斷模式
};

enum RGBColor : byte {
  RGB_OFF,
  RGB_GREEN,
  RGB_YELLOW,
  RGB_BLUE,
  RGB_RED,
  RGB_PURPLE,
  RGB_CYAN     // 新增：診斷模式用
};

// ============================================================================
// 全域變數
// ============================================================================

INA226_WE ina226;
const float MAX_CURRENT_A = 5.0;  // 請根據馬達規格調整
float current_A = 0.0;

MotionState motionState = IDLE;
MotorPhase currentPhase = PHASE_UNKNOWN;
SystemState currentSystemState = RUNNING;
ControlPriority currentPriority = PRIORITY_AUTO;

// 馬達控制
bool motorPowerOn = false;
uint32_t motorStartTime = 0;
const uint32_t MAX_MOTOR_RUN_TIME = 30000;  // 30秒超時保護
uint32_t lastPhaseChangeTime = 0;
const uint16_t MIN_PHASE_DURATION = 500;    // 防止相位抖動

// 速度測量
#define WHEEL_CIRCUMFERENCE 204.2  // 請根據實際輪胎周長(cm)調整
const uint16_t SPEED_TIMEOUT = 2000;
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t timeBetweenTriggers = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
uint32_t lastSpeedUpdate = 0;

// IMU 資料與健康狀態
float compAngleX = 0.0f;
float gyroBiasX = 0.0f;
float accelBiasX = 0.0f;
uint32_t lastIMUTime = 0;
bool i2cHealthy = true;
uint32_t lastI2CSuccess = 0;
const uint16_t I2C_TIMEOUT = 5000;

// 傾斜保護
const float SAFE_ANGLE = 10.0f;
const float TILT_SAFE = 5.0f;
const float EMERGENCY_ANGLE = 15.0f;
const uint16_t TILT_TRIGGER_TIME = 500;
const uint16_t AUTO_UP_DELAY = 3000;
uint32_t tiltStartTime = 0;
bool tiltWarning = false;
uint32_t safeStartTime = 0;

// 速度防抖與遲滯
const byte SPEED_STABLE_COUNT = 3;
byte speedLowCount = 0;
byte speedHighCount = 0;
const float SPEED_UP_THRESHOLD = 20.0;
const float SPEED_DOWN_THRESHOLD = 15.0;

// 控制變數
bool wheelDown = true;  // 預設輔助輪放下（安全狀態）
bool manualMode = false;
byte ctrlSrc = 0;

// 限位開關狀態記錄（用於去彈跳）
struct LimitSwitchState {
  bool current;
  bool lastStable;
  uint32_t lastChangeTime;
  const uint16_t debounceTime = 50;
};

LimitSwitchState limitLeftUp;
LimitSwitchState limitLeftDown;
LimitSwitchState limitRightUp;
LimitSwitchState limitRightDown;

// 緊急停止狀態
bool emergencyStopPressed = false;
bool manualResetConfirmed = false;  // 手動重置確認
uint32_t haltTime = 0;

// 時間控制
uint32_t lastPrintTime = 0;
uint32_t lastDisplayTime = 0;
uint32_t lastIRCode = 0;
const uint16_t IR_DELAY = 500;

// 非阻塞音效
uint32_t beepEndTime = 0;
bool isBeeping = false;

// 看門狗
uint32_t lastLoopTime = 0;
const uint32_t WATCHDOG_TIMEOUT = 2000;

// ============================================================================
// RGB LED 控制
// ============================================================================

void setRGB(byte r, byte g, byte b) {
  if (RGB_COMMON_ANODE) {
    analogWrite(RGB_RED_PIN, 255-r);
    analogWrite(RGB_GREEN_PIN, 255-g);
    analogWrite(RGB_BLUE_PIN, 255-b);
  } else {
    analogWrite(RGB_RED_PIN, r);
    analogWrite(RGB_GREEN_PIN, g);
    analogWrite(RGB_BLUE_PIN, b);
  }
}

void setRGBColor(RGBColor c) {
  switch(c) {
    case RGB_OFF: setRGB(0,0,0); break;
    case RGB_GREEN: setRGB(0,255,0); break;
    case RGB_YELLOW: setRGB(255,255,0); break;
    case RGB_BLUE: setRGB(0,0,255); break;
    case RGB_RED: setRGB(255,0,0); break;
    case RGB_PURPLE: setRGB(128,0,255); break;
    case RGB_CYAN: setRGB(0,255,255); break;
  }
}

RGBColor decideRGB() {
  if (currentSystemState == DIAGNOSTICS) return RGB_CYAN;
  
  switch(currentPriority) {
    case PRIORITY_EMERGENCY:
    case PRIORITY_COOLING:
      return RGB_RED;
    case PRIORITY_SAFETY_DOWN:
      return RGB_BLUE;
    case PRIORITY_MANUAL:
      return RGB_PURPLE;
    default:
      if (motionState == MOVING_DOWN) return RGB_YELLOW;
      if (motionState == MOVING_UP) return RGB_GREEN;
      return wheelDown ? RGB_YELLOW : RGB_GREEN;
  }
}

// ============================================================================
// 非阻塞音效
// ============================================================================

void beepStart(uint16_t freq, uint16_t duration) {
  tone(BUZZER_PIN, freq);
  beepEndTime = millis() + duration;
  isBeeping = true;
}

void beepUpdate() {
  if (isBeeping && millis() >= beepEndTime) {
    noTone(BUZZER_PIN);
    isBeeping = false;
  }
}

// ============================================================================
// 速度計算
// ============================================================================

void speedInterrupt() {
  uint32_t t = micros();
  if (t - lastSpeedTrigger > 40000) {
    timeBetweenTriggers = t - lastSpeedTrigger;
    lastSpeedTrigger = t;
    newSpeedData = true;
  }
}

float calculateSpeed() {
  if (timeBetweenTriggers == 0) return 0.0;
  float timeInSec = timeBetweenTriggers/1000000.0;
  return (WHEEL_CIRCUMFERENCE/timeInSec)*0.036;
}

// ============================================================================
// MPU6050 函式 - 安全版本
// ============================================================================

int16_t safeRead16(byte reg) {
  Wire.beginTransmission(MPU_6050);
  Wire.write(reg);
  byte error = Wire.endTransmission(false);

  if(error != 0) {
    i2cHealthy = false;
    return 0;
  }

  Wire.requestFrom((byte)MPU_6050, (byte)2);
  uint32_t start = millis();
  while (Wire.available() < 2) {
    if (millis() - start > 10) {
      i2cHealthy = false;
      return 0;
    }
  }

  i2cHealthy = true;
  lastI2CSuccess = millis();
  return (Wire.read()<<8)|Wire.read();
}

void setupMPU() {
  Wire.beginTransmission(MPU_6050);
  Wire.write(PWR_MGMT_1);
  Wire.write(0x00);
  Wire.endTransmission();
  delay(50);
}

void calibrateIMU() {
  Serial.println(F("Calibrating IMU..."));
  float sumAx=0, sumGx=0;
  for(byte i=0; i<50; i++) {
    sumAx += safeRead16(ACCEL_XOUT_H)/16384.0f;
    sumGx += safeRead16(GYRO_XOUT_H)/131.0f;
    delay(5);
  }
  accelBiasX = sumAx/50;
  gyroBiasX = sumGx/50;
  Serial.println(F("IMU Calibration Complete"));
}

void readIMU() {
  if(!i2cHealthy) return;

  uint32_t now = micros();
  float dt = (now - lastIMUTime) / 1000000.0;
  lastIMUTime = now;
  if (dt > 0.1) dt = 0.01;

  float ax = safeRead16(ACCEL_XOUT_H) / 16384.0f - accelBiasX;
  float az = safeRead16(ACCEL_XOUT_H + 4) / 16384.0f;
  float gx = safeRead16(GYRO_XOUT_H) / 131.0f - gyroBiasX;

  if(isnan(ax) || isnan(az) || isnan(gx) ||
     abs(ax) > 10 || abs(az) > 10 || abs(gx) > 500) {
    i2cHealthy = false;
    return;
  }

  float accelAngle = atan2(ax, az) * 57.2958f;
  compAngleX = 0.98 * (compAngleX + gx * dt) + 0.02 * accelAngle;

  if(compAngleX > 180) compAngleX = 180;
  if(compAngleX < -180) compAngleX = -180;
}

// ============================================================================
// 限位開關處理（帶去彈跳）
// ============================================================================

bool readLimitSwitch(LimitSwitchState &state, byte pin) {
  bool reading = (digitalRead(pin) == LOW);  // 假設為常開型，觸發時為LOW
  
  if (reading != state.current) {
    state.lastChangeTime = millis();
    state.current = reading;
  }
  
  if (millis() - state.lastChangeTime > state.debounceTime) {
    if (reading != state.lastStable) {
      state.lastStable = reading;
      return true;  // 狀態已改變且穩定
    }
  }
  
  return false;
}

bool isLimitTriggered(byte pin, LimitSwitchState &state) {
  readLimitSwitch(state, pin);
  return state.lastStable;
}

bool isFullyUp() {
  return isLimitTriggered(LIMIT_LEFT_UP_PIN, limitLeftUp) && 
         isLimitTriggered(LIMIT_RIGHT_UP_PIN, limitRightUp);
}

bool isFullyDown() {
  return isLimitTriggered(LIMIT_LEFT_DOWN_PIN, limitLeftDown) && 
         isLimitTriggered(LIMIT_RIGHT_DOWN_PIN, limitRightDown);
}

// ============================================================================
// 馬達相位追蹤
// ============================================================================

void updateMotorPhase() {
  MotorPhase oldPhase = currentPhase;
  
  // 根據限位開關判斷當前位置
  if (isFullyDown()) {
    currentPhase = PHASE_AT_DOWN;
  } else if (isFullyUp()) {
    currentPhase = PHASE_AT_UP;
  } else if (motorPowerOn) {
    // 馬達運行中，根據目標方向判斷
    if (motionState == MOVING_DOWN) {
      currentPhase = PHASE_EXTENDING;
    } else if (motionState == MOVING_UP) {
      currentPhase = PHASE_RETRACTING;
    }
  }
  
  // 記錄相位變化時間（防抖用）
  if (oldPhase != currentPhase) {
    lastPhaseChangeTime = millis();
    
    #if defined(DEBUG_MOTOR_PHASE)
    Serial.print(F("Phase: "));
    Serial.print(oldPhase);
    Serial.print(F(" -> "));
    Serial.println(currentPhase);
    #endif
  }
}

// ============================================================================
// OLED 顯示
// ============================================================================

void showStartupPro() {
  display.clearDisplay();
  display.setTextSize(3);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(15,10);
  display.print(F("BIKE"));
  display.setCursor(10,40);
  display.setTextSize(2);
  display.print(F("v5.0"));
  display.display();
  delay(1000);
}

void drawDashboard() {
  display.clearDisplay();

  // 速度顯示
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(4);
  int speedInt = (int)currentSpeed;
  display.setCursor(0, 0);
  display.print(speedInt);
  display.setTextSize(1);
  display.setCursor(50, 0);
  display.print(F("km/h"));

  // 角度顯示
  display.setTextSize(2);
  display.setCursor(0, 32);
  display.print(compAngleX, 1);
  display.print(F("'"));

  // 狀態行
  display.setTextSize(1);
  display.setCursor(64, 0);
  display.print(F("P:"));
  switch(currentPriority) {
    case PRIORITY_EMERGENCY: display.print(F("EMRG")); break;
    case PRIORITY_SAFETY_DOWN: display.print(F("SAFE")); break;
    case PRIORITY_COOLING: display.print(F("COOL")); break;
    case PRIORITY_MANUAL: display.print(F("MANU")); break;
    case PRIORITY_AUTO: display.print(F("AUTO")); break;
  }

  display.setCursor(64, 8);
  display.print(F("S:"));
  if(currentSystemState == RUNNING) display.print(F("RUN"));
  else if(currentSystemState == COOLING_DOWN) display.print(F("COOL"));
  else if(currentSystemState == DIAGNOSTICS) display.print(F("DIAG"));
  else display.print(F("EMRG"));

  display.setCursor(64, 16);
  display.print(F("T:"));
  display.print(wheelDown ? F("DN") : F("UP"));

  display.setCursor(64, 24);
  display.print(F("M:"));
  display.print(motorPowerOn ? F("ON") : F("OFF"));

  display.setCursor(64, 32);
  display.print(F("I:"));
  display.print(current_A, 1);
  display.print(F("A"));

  // 警告/狀態
  display.setCursor(64, 40);
  if(tiltWarning) display.print(F("TILT!"));
  else if(manualMode) display.print(F("MANUAL"));
  else if(!i2cHealthy) display.print(F("I2C ERR"));
  else if(currentPhase == PHASE_UNKNOWN) display.print(F("PH:UNK"));
  else display.print(F("OK"));

  // 限位開關狀態
  display.setCursor(0, 56);
  display.print(isLimitTriggered(LIMIT_LEFT_UP_PIN, limitLeftUp) ? F("LU") : F("--"));
  display.print(F(" "));
  display.print(isLimitTriggered(LIMIT_LEFT_DOWN_PIN, limitLeftDown) ? F("LD") : F("--"));
  display.print(F(" "));
  display.print(isLimitTriggered(LIMIT_RIGHT_UP_PIN, limitRightUp) ? F("RU") : F("--"));
  display.print(F(" "));
  display.print(isLimitTriggered(LIMIT_RIGHT_DOWN_PIN, limitRightDown) ? F("RD") : F("--"));

  display.display();
}

// ============================================================================
// 紅外線處理
// ============================================================================

void handleIRCommand(uint32_t code) {
  if(millis() - lastIRCode < IR_DELAY) return;
  lastIRCode = millis();

  if(currentPriority < PRIORITY_MANUAL) {
    Serial.println(F("IR: Blocked by higher priority"));
    beepStart(NOTE_C5, 100);
    return;
  }

  // 切換目標狀態
  wheelDown = !wheelDown;
  manualMode = true;
  ctrlSrc = 2;

  beepStart(NOTE_A5, 50);
  Serial.print(F("IR: Target "));
  Serial.println(wheelDown ? F("DOWN") : F("UP"));
}

// ============================================================================
// 優先權決策核心
// ============================================================================

void decidePriority() {
  // 【第0級】緊急停止
  if (emergencyStopPressed ||
      (!IGNORE_CURRENT_SENSOR && current_A > MAX_CURRENT_A) ||
      (abs(compAngleX) > EMERGENCY_ANGLE)) {
    currentPriority = PRIORITY_EMERGENCY;
    return;
  }

  // 【第1級】安全保護
  if (tiltWarning) {
    currentPriority = PRIORITY_SAFETY_DOWN;
    return;
  }
  
  if (!wheelDown && 
      currentSpeed < SPEED_DOWN_THRESHOLD && 
      speedLowCount >= SPEED_STABLE_COUNT) {
    currentPriority = PRIORITY_SAFETY_DOWN;
    return;
  }

  // 【第2級】冷卻鎖定
  if (currentSystemState == COOLING_DOWN) {
    currentPriority = PRIORITY_COOLING;
    return;
  }

  // 【第3級】手動控制
  if (manualMode) {
    currentPriority = PRIORITY_MANUAL;
    return;
  }

  // 【第4級】自動控制
  currentPriority = PRIORITY_AUTO;
}

// ============================================================================
// 根據優先權執行動作
// ============================================================================

void executeByPriority() {
  switch(currentPriority) {
    
    case PRIORITY_EMERGENCY:
      wheelDown = true;
      manualMode = false;
      ctrlSrc = 0;
      
      if(currentSystemState != COOLING_DOWN && currentSystemState != EMERGENCY) {
        currentSystemState = COOLING_DOWN;
        haltTime = millis();
        beepStart(NOTE_C6, 300);
        Serial.println(F("!!! EMERGENCY TRIGGERED !!!"));
      }
      break;
      
    case PRIORITY_SAFETY_DOWN:
      wheelDown = true;
      manualMode = false;
      ctrlSrc = 4;
      break;
      
    case PRIORITY_COOLING:
      wheelDown = true;
      manualMode = false;
      ctrlSrc = 0;
      break;
      
    case PRIORITY_MANUAL:
      ctrlSrc = 2;
      break;
      
    case PRIORITY_AUTO:
      // 飛機起降模式
      if(currentSpeed >= SPEED_UP_THRESHOLD && speedHighCount >= SPEED_STABLE_COUNT) {
        if(wheelDown) {
          wheelDown = false;
          ctrlSrc = 3;
          Serial.println(F("Auto: UP (Speed >= 20km/h)"));
        }
      } 
      else if(currentSpeed < SPEED_DOWN_THRESHOLD && speedLowCount >= SPEED_STABLE_COUNT) {
        if(!wheelDown) {
          wheelDown = true;
          ctrlSrc = 3;
          Serial.println(F("Auto: DOWN (Speed < 15km/h)"));
        }
      }
      break;
  }
}

// ============================================================================
// 運動控制核心（針對自動往返馬達）
// ============================================================================

void executeMotion() {
  // 更新馬達相位
  updateMotorPhase();
  
  // 超時保護
  if (motorPowerOn && (millis() - motorStartTime > MAX_MOTOR_RUN_TIME)) {
    motorPowerOn = false;
    digitalWrite(MOTOR_POWER_PIN, LOW);
  motorPowerOn = false;
  Serial.println(F("\n馬達已停止"));
  
  Serial.println(F("\n等待 3 秒後再次測試..."));
  delay(3000);
  
  Serial.println(F("馬達再次通電 5 秒（觀察方向是否改變）..."));
  digitalWrite(MOTOR_POWER_PIN, HIGH);
  motorPowerOn = true;
  
  for (int i = 5; i > 0; i--) {
    Serial.print(i);
    Serial.print(F("..."));
    beepStart(NOTE_A5, 100);
    delay(1000);
  }
  
  digitalWrite(MOTOR_POWER_PIN, LOW);
  motorPowerOn = false;
  Serial.println(F("\n馬達已停止"));
  
  // 3. 感測器狀態
  Serial.println(F("\n=== 感測器狀態 ==="));
  readIMU();
  Serial.print(F("角度: "));
  Serial.print(compAngleX, 2);
  Serial.println(F(" 度"));
  Serial.print(F("I2C 健康: "));
  Serial.println(i2cHealthy ? F("OK") : F("FAIL"));
  Serial.print(F("電流: "));
  Serial.print(current_A, 2);
  Serial.println(F(" A"));
  
  Serial.println(F("\n=== 診斷完成 ==="));
  Serial.println(F("按下重置按鈕恢復正常模式\n"));
  
  // 等待重置
  while (!manualResetConfirmed) {
    if (digitalRead(RESET_BUTTON_PIN) == LOW) {
      delay(50);
      if (digitalRead(RESET_BUTTON_PIN) == LOW) {
        manualResetConfirmed = true;
        beepStart(NOTE_C6, 200);
      }
    }
    setRGBColor(RGB_CYAN);
    delay(100);
    setRGBColor(RGB_OFF);
    delay(100);
  }
  
  currentSystemState = RUNNING;
  manualResetConfirmed = false;
}

// ============================================================================
// Setup
// ============================================================================

void setup() {
  wdt_disable();
  Serial.begin(115200);
  delay(100);

  Wire.begin();
  Wire.setClock(100000);
  
  #if defined(ARDUINO_ARCH_AVR)
    Wire.setWireTimeout(3000, true);
  #endif

  // 腳位初始化
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(MOTOR_POWER_PIN, OUTPUT);
  pinMode(LIMIT_LEFT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_LEFT_DOWN_PIN, INPUT_PULLUP);
  pinMode(LIMIT_RIGHT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_RIGHT_DOWN_PIN, INPUT_PULLUP);
  pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);
  pinMode(RGB_RED_PIN, OUTPUT);
  pinMode(RGB_GREEN_PIN, OUTPUT);
  pinMode(RGB_BLUE_PIN, OUTPUT);

  digitalWrite(MOTOR_POWER_PIN, LOW);
  setRGBColor(RGB_OFF);

  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("OLED Fail"));
    while(1);
  }

  ina226.init();
  setupMPU();
  calibrateIMU();

  showStartupPro();
  beepStart(NOTE_C6, 100);

  Serial.println(F("============================"));
  Serial.println(F("  BIKE ASSIST v5.0"));
  Serial.println(F("  自動往返馬達版"));
  Serial.println(F("============================"));

  // 系統診斷
  Serial.println(F("\n=== 系統診斷 ==="));
  Serial.print(F("Emergency Pin: "));
  Serial.println(digitalRead(EMERGENCY_STOP_PIN) ? F("HIGH") : F("LOW"));
  Serial.print(F("Reset Pin: "));
  Serial.println(digitalRead(RESET_BUTTON_PIN) ? F("HIGH") : F("LOW"));
  
  Serial.println(F("\n=== 限位開關初始狀態 ==="));
  Serial.print(F("左上: ")); 
  Serial.println(isLimitTriggered(LIMIT_LEFT_UP_PIN, limitLeftUp) ? F("觸發") : F("未觸發"));
  Serial.print(F("左下: ")); 
  Serial.println(isLimitTriggered(LIMIT_LEFT_DOWN_PIN, limitLeftDown) ? F("觸發") : F("未觸發"));
  Serial.print(F("右上: ")); 
  Serial.println(isLimitTriggered(LIMIT_RIGHT_UP_PIN, limitRightUp) ? F("觸發") : F("未觸發"));
  Serial.print(F("右下: ")); 
  Serial.println(isLimitTriggered(LIMIT_RIGHT_DOWN_PIN, limitRightDown) ? F("觸發") : F("未觸發"));

  Serial.println(F("\n=== IMU 狀態 ==="));
  readIMU();
  Serial.print(F("Initial Angle: "));
  Serial.print(compAngleX, 2);
  Serial.println(F(" degrees"));
  Serial.print(F("I2C Health: "));
  Serial.println(i2cHealthy ? F("OK") : F("FAIL"));

  if(abs(compAngleX) > 90) {
    Serial.println(F("⚠️  WARNING: IMU angle abnormal!"));
    compAngleX = 0;
  }

  Serial.println(F("================\n"));

  // 如果啟用診斷模式
  if (ENABLE_DIAGNOSTICS) {
    runDiagnostics();
  }

  lastI2CSuccess = millis();
  lastLoopTime = millis();
  lastIMUTime = micros();
  
  wdt_enable(WDTO_2S);
}

// ============================================================================
// Loop 主迴圈
// ============================================================================

void loop() {
  wdt_reset();
  uint32_t currentMillis = millis();

  // ========== 看門狗 ==========
  if(currentMillis - lastLoopTime > WATCHDOG_TIMEOUT) {
    Serial.println(F("!!! WATCHDOG RESET !!!"));
    
    motorPowerOn = false;
    digitalWrite(MOTOR_POWER_PIN, LOW);
    motionState = IDLE;
    currentSystemState = RUNNING;
    currentPriority = PRIORITY_AUTO;
    currentPhase = PHASE_UNKNOWN;
    tiltWarning = false;
    manualMode = false;
    speedLowCount = 0;
    speedHighCount = 0;
    tiltStartTime = 0;
    safeStartTime = 0;
    
    beepStart(NOTE_A5, 300);
  }
  lastLoopTime = currentMillis;

  // ========== I2C 健康檢查與恢復 ==========
  if(!i2cHealthy && (millis() - lastI2CSuccess > I2C_TIMEOUT)) {
    Serial.println(F("!!! I2C TIMEOUT - RESET !!!"));
    
    Wire.end();
    delay(100);
    Wire.begin();
    Wire.setClock(100000);
    setupMPU();
    
    compAngleX = 0;
    i2cHealthy = true;
    lastI2CSuccess = millis();
    
    beepStart(NOTE_C5, 200);
  }

  // ========== 非阻塞音效更新 ==========
  beepUpdate();

  // ========== 讀取感測器 ==========
  readIMU();

  if(IGNORE_CURRENT_SENSOR) {
    current_A = 0.0;
  } else {
    float tempCurrent = ina226.getCurrent_A();
    if(isnan(tempCurrent) || tempCurrent < -1.0 || tempCurrent > 10.0) {
      current_A = 0.0;
    } else {
      current_A = tempCurrent;
    }
  }

  // 速度更新
  if(newSpeedData) {
    currentSpeed = calculateSpeed();
    newSpeedData = false;
    lastSpeedUpdate = millis();
  }

  if(millis() - lastSpeedUpdate > SPEED_TIMEOUT) {
    currentSpeed = 0.0;
  }

  // ========== 速度防抖計數 ==========
  if(currentSpeed < SPEED_DOWN_THRESHOLD) {
    speedLowCount = min(speedLowCount + 1, SPEED_STABLE_COUNT);
    speedHighCount = 0;
  } else if(currentSpeed >= SPEED_UP_THRESHOLD) {
    speedHighCount = min(speedHighCount + 1, SPEED_STABLE_COUNT);
    speedLowCount = 0;
  } else {
    speedLowCount = (speedLowCount > 0) ? speedLowCount - 1 : 0;
    speedHighCount = (speedHighCount > 0) ? speedHighCount - 1 : 0;
  }

  // ========== 紅外線接收 ==========
  if(IrReceiver.decode()) {
    handleIRCommand(IrReceiver.decodedIRData.decodedRawData);
    IrReceiver.resume();
  }

  // ========== 緊急按鈕檢查 ==========
  if(BUTTON_IS_NC_TYPE) {
    emergencyStopPressed = (digitalRead(EMERGENCY_STOP_PIN) == HIGH);
  } else {
    emergencyStopPressed = (digitalRead(EMERGENCY_STOP_PIN) == LOW);
  }

  // ========== 手動重置檢查 ==========
  if (currentSystemState == COOLING_DOWN) {
    if (digitalRead(RESET_BUTTON_PIN) == LOW) {
      delay(50);  // 簡單去彈跳
      if (digitalRead(RESET_BUTTON_PIN) == LOW) {
        manualResetConfirmed = true;
      }
    }
  }

  // ========== 傾斜檢測 ==========
  if(abs(compAngleX) > SAFE_ANGLE) {
    if(tiltStartTime == 0) tiltStartTime = millis();
    if(!tiltWarning && (millis() - tiltStartTime >= TILT_TRIGGER_TIME)) {
      tiltWarning = true;
      Serial.println(F(">>> TILT WARN"));
      beepStart(NOTE_C6, 200);
    }
  } else {
    tiltStartTime = 0;
    if(tiltWarning && abs(compAngleX) < TILT_SAFE) {
      if(safeStartTime == 0) safeStartTime = millis();
      if(millis() - safeStartTime >= AUTO_UP_DELAY) {
        tiltWarning = false;
        if(!manualMode && currentPriority == PRIORITY_AUTO) {
          wheelDown = false;
          ctrlSrc = 4;
        }
        Serial.println(F("<<< TILT OK"));
        safeStartTime = 0;
      }
    } else {
      safeStartTime = 0;
    }
  }

  // ========== 優先權決策 ==========
  decidePriority();

  // ========== 根據優先權執行動作 ==========
  executeByPriority();

  // ========== 冷卻恢復檢查（需手動重置）==========
  if(currentSystemState == COOLING_DOWN && manualResetConfirmed) {
    currentSystemState = RUNNING;
    currentPriority = PRIORITY_AUTO;
    manualMode = false;
    emergencyStopPressed = false;
    manualResetConfirmed = false;
    
    Serial.println(F("<<< MANUAL RESET CONFIRMED >>>"));
    beepStart(NOTE_C5, 100);
    delay(100);
    beepStart(NOTE_E5, 100);
  }

  // ========== 執行運動控制 ==========
  executeMotion();

  // ========== RGB LED 狀態顯示 ==========
  setRGBColor(decideRGB());

  // ========== OLED 螢幕更新 ==========
  if(millis() - lastDisplayTime > 250) {
    lastDisplayTime = millis();
    drawDashboard();
  }

  // ========== 序列埠輸出 ==========
  if(millis() - lastPrintTime > 1000) {
    lastPrintTime = millis();

    Serial.print(F("Priority:"));
    switch(currentPriority) {
      case PRIORITY_EMERGENCY: Serial.print(F("EMRG")); break;
      case PRIORITY_SAFETY_DOWN: Serial.print(F("SAFE")); break;
      case PRIORITY_COOLING: Serial.print(F("COOL")); break;
      case PRIORITY_MANUAL: Serial.print(F("MANU")); break;
      case PRIORITY_AUTO: Serial.print(F("AUTO")); break;
    }

    Serial.print(F(" |Sys:"));
    if(currentSystemState == RUNNING) Serial.print(F("RUN"));
    else if(currentSystemState == COOLING_DOWN) Serial.print(F("COOL"));
    else if(currentSystemState == DIAGNOSTICS) Serial.print(F("DIAG"));
    else Serial.print(F("EMRG"));

    Serial.print(F(" |Motion:"));
    if(motionState == MOVING_UP) Serial.print(F("^UP^"));
    else if(motionState == MOVING_DOWN) Serial.print(F("vDNv"));
    else if(motionState == WAITING_REVERSE) Serial.print(F("WAIT"));
    else Serial.print(F("IDLE"));

    Serial.print(F(" |Phase:"));
    switch(currentPhase) {
      case PHASE_UNKNOWN: Serial.print(F("UNK")); break;
      case PHASE_EXTENDING: Serial.print(F("EXT")); break;
      case PHASE_RETRACTING: Serial.print(F("RET")); break;
      case PHASE_AT_DOWN: Serial.print(F("@DN")); break;
      case PHASE_AT_UP: Serial.print(F("@UP")); break;
    }

    Serial.print(F(" |Target:"));
    Serial.print(wheelDown ? F("DN") : F("UP"));

    Serial.print(F(" |Lim:"));
    Serial.print(isFullyUp() ? F("UP") : F("--"));
    Serial.print(F("/"));
    Serial.print(isFullyDown() ? F("DN") : F("--"));

    Serial.print(F(" |Spd:"));
    Serial.print(currentSpeed, 1);
    Serial.print(F("km/h"));

    Serial.print(F(" |Ang:"));
    Serial.print(compAngleX, 1);
    Serial.print(F("'"));

    Serial.print(F(" |Motor:"));
    Serial.print(motorPowerOn ? F("ON") : F("OFF"));

    Serial.print(F(" |I:"));
    Serial.print(current_A, 2);
    Serial.print(F("A"));

    Serial.print(F(" |SpdCnt:L"));
    Serial.print(speedLowCount);
    Serial.print(F("/H"));
    Serial.print(speedHighCount);

    if(tiltWarning) Serial.print(F(" [TILT!]"));
    if(manualMode) Serial.print(F(" [MANUAL]"));
    if(emergencyStopPressed) Serial.print(F(" [EMRG-BTN]"));
    if(!i2cHealthy) Serial.print(F(" [I2C-ERR]"));

    Serial.print(F(" Src:"));
    switch(ctrlSrc) {
      case 0: Serial.print(F("--")); break;
      case 1: Serial.print(F("LIM")); break;
      case 2: Serial.print(F("IR")); break;
      case 3: Serial.print(F("AUTO")); break;
      case 4: Serial.print(F("TILT")); break;
    }

    Serial.println();
  }

  delay(2);
} LOW);
    
    currentSystemState = COOLING_DOWN;
    haltTime = millis();
    
    Serial.println(F("!!! MOTOR TIMEOUT !!!"));
    beepStart(NOTE_C6, 500);
    return;
  }
  
  // 只有在 RUNNING 狀態才能移動
  if (currentSystemState != RUNNING) {
    if (motorPowerOn) {
      motorPowerOn = false;
      digitalWrite(MOTOR_POWER_PIN, LOW);
      motionState = IDLE;
    }
    return;
  }
  
  // ========== 決策邏輯 ==========
  bool shouldRun = false;
  MotionState desiredState = IDLE;
  
  if (wheelDown) {
    // 目標：放下輔助輪
    if (isFullyDown()) {
      // 已經在下限，停止
      desiredState = IDLE;
    } else {
      // 需要移動
      if (currentPhase == PHASE_AT_UP || currentPhase == PHASE_EXTENDING) {
        // 在上限或正在伸出 → 可以通電
        shouldRun = true;
        desiredState = MOVING_DOWN;
      } else if (currentPhase == PHASE_RETRACTING) {
        // 馬達正在縮回（錯誤方向）→ 等待到達上限後自動換向
        desiredState = WAITING_REVERSE;
        Serial.println(F("Waiting for motor to reach top..."));
      }
    }
  } else {
    // 目標：收起輔助輪
    if (isFullyUp()) {
      // 已經在上限，停止
      desiredState = IDLE;
    } else {
      // 需要移動
      if (currentPhase == PHASE_AT_DOWN || currentPhase == PHASE_RETRACTING) {
        // 在下限或正在縮回 → 可以通電
        shouldRun = true;
        desiredState = MOVING_UP;
      } else if (currentPhase == PHASE_EXTENDING) {
        // 馬達正在伸出（錯誤方向）→ 等待到達下限後自動換向
        desiredState = WAITING_REVERSE;
        Serial.println(F("Waiting for motor to reach bottom..."));
      }
    }
  }
  
  // ========== 執行動作 ==========
  motionState = desiredState;
  
  if (shouldRun && !motorPowerOn) {
    // 啟動馬達
    motorPowerOn = true;
    digitalWrite(MOTOR_POWER_PIN, HIGH);
    motorStartTime = millis();
    Serial.println(F(">>> MOTOR ON"));
  } else if (!shouldRun && motorPowerOn) {
    // 停止馬達
    motorPowerOn = false;
    digitalWrite(MOTOR_POWER_PIN, LOW);
    Serial.println(F("<<< MOTOR OFF"));
    
    // 到位提示音
    if (desiredState == IDLE) {
      beepStart(NOTE_E5, 100);
    }
  }
}

// ============================================================================
// 診斷模式
// ============================================================================

void runDiagnostics() {
  currentSystemState = DIAGNOSTICS;
  Serial.println(F("\n========================================"));
  Serial.println(F("        診斷模式啟動"));
  Serial.println(F("========================================\n"));
  
  // 1. 限位開關測試
  Serial.println(F("=== 限位開關測試 (10秒) ==="));
  Serial.println(F("請手動觸發每個磁簧開關..."));
  
  for (int i = 0; i < 20; i++) {
    Serial.print(F("左上:"));
    Serial.print(isLimitTriggered(LIMIT_LEFT_UP_PIN, limitLeftUp) ? F("[X]") : F("[ ]"));
    Serial.print(F(" 左下:"));
    Serial.print(isLimitTriggered(LIMIT_LEFT_DOWN_PIN, limitLeftDown) ? F("[X]") : F("[ ]"));
    Serial.print(F(" 右上:"));
    Serial.print(isLimitTriggered(LIMIT_RIGHT_UP_PIN, limitRightUp) ? F("[X]") : F("[ ]"));
    Serial.print(F(" 右下:"));
    Serial.println(isLimitTriggered(LIMIT_RIGHT_DOWN_PIN, limitRightDown) ? F("[X]") : F("[ ]"));
    
    setRGBColor(RGB_CYAN);
    delay(500);
  }
  
  // 2. 馬達測試
  Serial.println(F("\n=== 馬達行為測試 ==="));
  Serial.println(F("馬達將通電 5 秒..."));
  
  digitalWrite(MOTOR_POWER_PIN, HIGH);
  motorPowerOn = true;
  motorStartTime = millis();
  
  for (int i = 5; i > 0; i--) {
    Serial.print(i);
    Serial.print(F("..."));
    beepStart(NOTE_C5, 100);
    delay(1000);
  }
  
  digitalWrite(MOTOR_POWER_PIN,
