/*
 * æ™ºæ…§è¼”åŠ©è¼ªç³»çµ± - ç°¡åŒ–ç‰ˆï¼ˆé †åºåˆ‡æ› IR æ§åˆ¶ï¼‰
 * 
 * è¨­è¨ˆç†å¿µï¼š
 * - ç¹¼é›»å™¨ ON  = è¼”åŠ©è¼ªä¸Šå‡
 * - ç¹¼é›»å™¨ OFF = è¼”åŠ©è¼ªä¸‹é™ï¼ˆé‡åŠ›ï¼‰
 * - IR é™æ§ï¼šä»»æ„æŒ‰éµé †åºåˆ‡æ›ï¼ˆä¸Šå‡â†’ä¸‹é™â†’åœæ­¢â†’ä¸Šå‡...ï¼‰
 * 
 * åŠŸèƒ½ï¼š
 * 1. é–‹æ©Ÿè‡ªå‹•æ­¸é›¶ï¼ˆç­‰å¾…ä¸‹é™åˆ°åº•ï¼‰
 * 2. é€Ÿåº¦ > 15km/h â†’ è‡ªå‹•ä¸Šå‡
 * 3. é€Ÿåº¦ < 15km/h â†’ è‡ªå‹•ä¸‹é™
 * 4. IR ä»»æ„éµé †åºåˆ‡æ›æ§åˆ¶æ¨¡å¼
 * 5. ç£ç°§é–‹é—œé˜²å‘†
 * 
 * ç¡¬é«”ï¼š
 * - Arduino Mega 2560
 * - DC ç·šæ€§è‡´å‹•å™¨
 * - ç¹¼é›»å™¨æ¨¡çµ„
 * - éœçˆ¾é€Ÿåº¦æ„Ÿæ¸¬å™¨
 * - ç£ç°§é–‹é—œ x2
 * - IR é™æ§å™¨ï¼ˆä»»æ„ï¼‰
 * - OLED SSD1306
 * - RGB LED
 * 
 * ä½œè€…ï¼šæ—æ©åœ˜éšŠ
 * ç‰ˆæœ¬ï¼šv1.0
 * æ—¥æœŸï¼š2026/01/22
 */

#include <Wire.h>
#include <IRremote.hpp>
#include <U8g2lib.h>

// ==================== ğŸ›ï¸ å¯èª¿æ•´åƒæ•¸ ====================

// ã€åƒæ•¸ 1ã€‘é€Ÿåº¦é–¾å€¼ï¼ˆkm/hï¼‰
const float SPEED_THRESHOLD = 15.0;

// ã€åƒæ•¸ 2ã€‘è¼ªèƒå‘¨é•·ï¼ˆmmï¼‰- å¯¦æ¸¬ä½ çš„è…³è¸è»Š
const float WHEEL_CIRCUMFERENCE = 2042.0;  // 700C è¼ªèƒ

// ã€åƒæ•¸ 3ã€‘æ­¸é›¶è¶…æ™‚ï¼ˆæ¯«ç§’ï¼‰
const unsigned long HOMING_TIMEOUT = 20000;  // 20 ç§’

// ã€åƒæ•¸ 4ã€‘ç£ç°§å»å½ˆè·³ï¼ˆæ¯«ç§’ï¼‰
const unsigned long DEBOUNCE_DELAY = 50;

// ã€åƒæ•¸ 5ã€‘é¦¬é”å‹•ä½œæœ€å°é–“éš”ï¼ˆæ¯«ç§’ï¼‰
const unsigned long MOTOR_CHANGE_DELAY = 1000;  // 1 ç§’

// ã€åƒæ•¸ 6ã€‘é€Ÿåº¦å¹³æ»‘ä¿‚æ•¸ï¼ˆ0.0-1.0ï¼‰
const float SPEED_SMOOTH_ALPHA = 0.3;  // è¶Šå°è¶Šå¹³æ»‘

// ã€åƒæ•¸ 7ã€‘IR æŒ‰éµé˜²æŠ–å»¶é²ï¼ˆæ¯«ç§’ï¼‰
const unsigned long IR_DEBOUNCE = 300;  // 300ms

// ==================== ğŸ”Œ ç¡¬é«”æ¥è…³å®šç¾© ====================

// é¦¬é”æ§åˆ¶
const uint8_t RELAY_PIN = 22;          // ç¹¼é›»å™¨ï¼ˆON=ä¸Šå‡, OFF=ä¸‹é™ï¼‰

// æ„Ÿæ¸¬å™¨
const uint8_t LIMIT_UP_PIN = 13;       // ä¸Šé™ç£ç°§ï¼ˆè§¸ç™¼=LOWï¼‰
const uint8_t LIMIT_DOWN_PIN = 53;     // ä¸‹é™ç£ç°§ï¼ˆè§¸ç™¼=LOWï¼‰
const uint8_t HALL_SPEED_PIN = 2;      // éœçˆ¾æ„Ÿæ¸¬ï¼ˆä¸­æ–·è…³ï¼‰
const uint8_t IR_RECEIVE_PIN = 3;      // IR æ¥æ”¶

// é¡¯ç¤ºèˆ‡æŒ‡ç¤º
const uint8_t RGB_RED_PIN = 5;
const uint8_t RGB_GREEN_PIN = 6;
const uint8_t RGB_BLUE_PIN = 7;
const uint8_t BUZZER_PIN = 8;

// ==================== ğŸ§© ç³»çµ±ç‹€æ…‹å®šç¾© ====================

enum Priority {
    P_MANUAL = 0,      // æ‰‹å‹•æ§åˆ¶ï¼ˆæœ€é«˜å„ªå…ˆï¼‰
    P_SPEED = 1,       // é€Ÿåº¦è§¸ç™¼
    P_IDLE = 2         // é–’ç½®
};

enum IRMode {
    IR_MODE_UP = 0,     // ä¸Šå‡æ¨¡å¼
    IR_MODE_DOWN = 1,   // ä¸‹é™æ¨¡å¼
    IR_MODE_STOP = 2    // åœæ­¢æ¨¡å¼ï¼ˆè‡ªå‹•ï¼‰
};

struct Command {
    Priority priority;
    bool wantUp;       // true=æƒ³ä¸Šå‡, false=æƒ³ä¸‹é™
    String reason;
    
    Command(Priority p, bool u, String r) 
        : priority(p), wantUp(u), reason(r) {}
    
    Command() : priority(P_IDLE), wantUp(false), reason("å¾…æ©Ÿ") {}
};

// ==================== ğŸŒ å…¨åŸŸç‰©ä»¶èˆ‡è®Šæ•¸ ====================

U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// é€Ÿåº¦æ¸¬é‡
volatile unsigned long lastSpeedTrigger = 0;
volatile unsigned long speedInterval = 0;
float currentSpeed = 0;
float smoothSpeed = 0;

// ç•¶å‰æŒ‡ä»¤
Command activeCommand;

// é¦¬é”ç‹€æ…‹
bool motorOn = false;
unsigned long lastMotorChange = 0;

// IR é™æ§ç‹€æ…‹
IRMode currentIRMode = IR_MODE_STOP;  // åˆå§‹ï¼šåœæ­¢æ¨¡å¼ï¼ˆè‡ªå‹•æ§åˆ¶ï¼‰
unsigned long lastIRTime = 0;

// ç³»çµ±ç‹€æ…‹
bool systemReady = false;

// ==================== âš¡ é€Ÿåº¦æ¸¬é‡ï¼ˆä¸­æ–·ï¼‰ ====================

void speedInterrupt() {
    unsigned long now = micros();
    speedInterval = now - lastSpeedTrigger;
    lastSpeedTrigger = now;
}

// ==================== ğŸ“Š è¨ˆç®—é€Ÿåº¦ ====================

float calculateSpeed() {
    // 2 ç§’æ²’è§¸ç™¼ = éœæ­¢
    if (micros() - lastSpeedTrigger > 2000000) {
        smoothSpeed = 0;
        return 0.0;
    }
    
    if (speedInterval == 0) {
        return 0.0;
    }
    
    // é€Ÿåº¦ (km/h) = (å‘¨é•· mm / æ™‚é–“ Î¼s) Ã— 3.6
    float rawSpeed = (WHEEL_CIRCUMFERENCE / speedInterval) * 3.6;
    
    // é™åˆ¶åˆç†ç¯„åœ
    if (rawSpeed > 80.0 || rawSpeed < 0) {
        rawSpeed = 0;
    }
    
    // å¹³æ»‘è™•ç†
    smoothSpeed = SPEED_SMOOTH_ALPHA * rawSpeed + (1 - SPEED_SMOOTH_ALPHA) * smoothSpeed;
    
    return smoothSpeed;
}

// ==================== ğŸ® IR é™æ§ï¼ˆé †åºåˆ‡æ›ï¼‰====================

Command checkManual() {
    if (IrReceiver.decode()) {
        // å–å¾—ä»»æ„æŒ‰éµç¢¼
        uint32_t code = IrReceiver.decodedIRData.decodedRawData;
        
        // é˜²æŠ–ï¼š300ms å…§ä¸é‡è¤‡è§¸ç™¼
        if (millis() - lastIRTime > IR_DEBOUNCE) {
            // å¿½ç•¥é‡è¤‡ç¢¼ï¼ˆæŒ‰ä½ä¸æ”¾ï¼‰
            if (code != 0xFFFFFFFF && code != 0) {
                // åˆ‡æ›åˆ°ä¸‹ä¸€å€‹æ¨¡å¼
                currentIRMode = (IRMode)((currentIRMode + 1) % 3);
                
                // è¦–è¦ºèˆ‡è²éŸ³å›é¥‹
                switch (currentIRMode) {
                    case IR_MODE_UP:
                        Serial.println("IR: åˆ‡æ›åˆ°ã€ä¸Šå‡ã€‘æ¨¡å¼");
                        beep(1500, 100);  // é«˜éŸ³çŸ­å—¶
                        setRGB(0, 0, 255); // è—ç‡ˆ
                        break;
                        
                    case IR_MODE_DOWN:
                        Serial.println("IR: åˆ‡æ›åˆ°ã€ä¸‹é™ã€‘æ¨¡å¼");
                        beep(1000, 100);  // ä¸­éŸ³çŸ­å—¶
                        setRGB(255, 255, 0); // é»ƒç‡ˆ
                        break;
                        
                    case IR_MODE_STOP:
                        Serial.println("IR: åˆ‡æ›åˆ°ã€è‡ªå‹•ã€‘æ¨¡å¼");
                        beep(500, 200);   // ä½éŸ³é•·å—¶
                        setRGB(0, 255, 0); // ç¶ ç‡ˆ
                        break;
                }
                
                lastIRTime = millis();
            }
        }
        
        IrReceiver.resume();
    }
    
    // æ ¹æ“šç•¶å‰æ¨¡å¼å›å‚³æŒ‡ä»¤
    switch (currentIRMode) {
        case IR_MODE_UP:
            return Command(P_MANUAL, true, "IRæ‰‹å‹•-ä¸Šå‡");
            
        case IR_MODE_DOWN:
            return Command(P_MANUAL, false, "IRæ‰‹å‹•-ä¸‹é™");
            
        case IR_MODE_STOP:
        default:
            return Command();  // IDLEï¼ˆäº¤çµ¦é€Ÿåº¦æ§åˆ¶ï¼‰
    }
}

// ==================== ğŸƒ é€Ÿåº¦åˆ¤æ–· ====================

Command checkSpeed() {
    if (currentSpeed > SPEED_THRESHOLD) {
        return Command(P_SPEED, true, "é€Ÿåº¦å¿«-ä¸Šå‡");
    } else {
        return Command(P_SPEED, false, "é€Ÿåº¦æ…¢-ä¸‹é™");
    }
}

// ==================== ğŸ¨ RGB æ§åˆ¶ ====================

void setRGB(uint8_t r, uint8_t g, uint8_t b) {
    analogWrite(RGB_RED_PIN, r);
    analogWrite(RGB_GREEN_PIN, g);
    analogWrite(RGB_BLUE_PIN, b);
}

// ==================== ğŸ”Š èœ‚é³´å™¨ ====================

void beep(int freq, int duration) {
    tone(BUZZER_PIN, freq, duration);
}

// ==================== ğŸ–¥ï¸ OLED é¡¯ç¤º ====================

void updateDisplay() {
    u8g2.clearBuffer();
    
    // === ç¬¬ä¸€è¡Œï¼šæ¨™é¡Œ ===
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 10, "Training Wheel v1.0");
    
    // === ç¬¬äºŒè¡Œï¼šIR æ¨¡å¼ ===
    u8g2.setFont(u8g2_font_6x10_tr);
    String modeStr = "IR: ";
    switch (currentIRMode) {
        case IR_MODE_UP:   modeStr += "UP"; break;
        case IR_MODE_DOWN: modeStr += "DOWN"; break;
        case IR_MODE_STOP: modeStr += "AUTO"; break;
    }
    u8g2.drawStr(0, 25, modeStr.c_str());
    
    // === ç¬¬ä¸‰è¡Œï¼šç•¶å‰æŒ‡ä»¤ ===
    String cmdStr = activeCommand.reason;
    u8g2.drawStr(0, 38, cmdStr.c_str());
    
    // === ç¬¬å››è¡Œï¼šé€Ÿåº¦ ===
    String speedStr = "Spd:" + String(currentSpeed, 1) + " km/h";
    u8g2.drawStr(0, 51, speedStr.c_str());
    
    // === ç¬¬äº”è¡Œï¼šç£ç°§èˆ‡é¦¬é”ç‹€æ…‹ ===
    bool atTop = (digitalRead(LIMIT_UP_PIN) == LOW);
    bool atBottom = (digitalRead(LIMIT_DOWN_PIN) == LOW);
    
    String statusStr = "";
    if (atTop) statusStr += "TOP ";
    if (atBottom) statusStr += "BTM ";
    if (!atTop && !atBottom) statusStr += "MID ";
    statusStr += motorOn ? "[ON]" : "[OFF]";
    
    u8g2.drawStr(0, 64, statusStr.c_str());
    
    u8g2.sendBuffer();
}

// ==================== ğŸš— é¦¬é”æ§åˆ¶ ====================

void setMotor(bool on) {
    // æª¢æŸ¥ 1: ç‹€æ…‹ç›¸åŒ â†’ ä¸å‹•ä½œ
    if (on == motorOn) {
        return;
    }
    
    // æª¢æŸ¥ 2: é˜²æ­¢é »ç¹åˆ‡æ›
    if (millis() - lastMotorChange < MOTOR_CHANGE_DELAY) {
        return;
    }
    
    // åŸ·è¡Œæ”¹è®Š
    motorOn = on;
    lastMotorChange = millis();
    digitalWrite(RELAY_PIN, on ? HIGH : LOW);
    
    // RGB æŒ‡ç¤ºï¼ˆåªåœ¨éæ‰‹å‹•æ¨¡å¼æ‰æ”¹è®Šé¡è‰²ï¼‰
    if (currentIRMode == IR_MODE_STOP) {
        if (on) {
            setRGB(0, 0, 255);  // è—è‰² = ä¸Šå‡
        } else {
            setRGB(255, 255, 0);  // é»ƒè‰² = ä¸‹é™
        }
    }
    
    Serial.print("é¦¬é”: ");
    Serial.println(on ? "ON (ä¸Šå‡)" : "OFF (ä¸‹é™)");
}

void stopMotor() {
    setMotor(false);
    if (currentIRMode == IR_MODE_STOP) {
        setRGB(0, 255, 0);  // ç¶ è‰² = åœæ­¢ï¼ˆè‡ªå‹•æ¨¡å¼ï¼‰
    }
}

// ==================== ğŸ¯ åŸ·è¡ŒæŒ‡ä»¤ ====================

void executeCommand(Command cmd) {
    // è®€å–ç£ç°§ç‹€æ…‹
    bool atTop = (digitalRead(LIMIT_UP_PIN) == LOW);
    bool atBottom = (digitalRead(LIMIT_DOWN_PIN) == LOW);
    
    // é˜²å‘† 1ï¼šå·²åœ¨ä¸Šé™ + æƒ³ä¸Šå‡ â†’ åœæ­¢
    if (atTop && cmd.wantUp) {
        Serial.println("âš ï¸ å·²åœ¨ä¸Šé™ï¼Œç¦æ­¢ä¸Šå‡");
        stopMotor();
        return;
    }
    
    // é˜²å‘† 2ï¼šå·²åœ¨ä¸‹é™ + æƒ³ä¸‹é™ â†’ åœæ­¢
    if (atBottom && !cmd.wantUp) {
        Serial.println("âš ï¸ å·²åœ¨ä¸‹é™ï¼Œç¦æ­¢ä¸‹é™");
        stopMotor();
        return;
    }
    
    // é–’ç½®ç‹€æ…‹ â†’ åœæ­¢
    if (cmd.priority == P_IDLE) {
        stopMotor();
        return;
    }
    
    // åŸ·è¡Œå‹•ä½œ
    if (cmd.wantUp) {
        setMotor(true);   // ç¹¼é›»å™¨ ON = ä¸Šå‡
    } else {
        setMotor(false);  // ç¹¼é›»å™¨ OFF = ä¸‹é™
    }
}

// ==================== ğŸ è‡ªå‹•æ­¸é›¶ ====================

void autoHoming() {
    Serial.println("\n========== é–‹å§‹æ­¸é›¶ ==========");
    
    // é¡¯ç¤ºè¨Šæ¯
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 25, "Homing...");
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(0, 40, "Waiting down limit");
    u8g2.sendBuffer();
    
    // ç¢ºä¿ç¹¼é›»å™¨é—œé–‰ï¼ˆè®“è¼”åŠ©è¼ªè‡ªç„¶ä¸‹é™ï¼‰
    digitalWrite(RELAY_PIN, LOW);
    motorOn = false;
    
    unsigned long startTime = millis();
    bool ledState = false;
    
    // ç­‰å¾…ä¸‹é™è§¸ç™¼
    while (digitalRead(LIMIT_DOWN_PIN) == HIGH) {
        // è¶…æ™‚æª¢æŸ¥
        if (millis() - startTime > HOMING_TIMEOUT) {
            Serial.println("âŒ æ­¸é›¶è¶…æ™‚ï¼");
            u8g2.clearBuffer();
            u8g2.setFont(u8g2_font_ncenB08_tr);
            u8g2.drawStr(0, 30, "ERROR:");
            u8g2.drawStr(0, 45, "Homing timeout!");
            u8g2.sendBuffer();
            
            // éŒ¯èª¤æç¤º
            for (int i = 0; i < 5; i++) {
                setRGB(255, 0, 0);
                beep(1000, 200);
                delay(200);
                setRGB(0, 0, 0);
                delay(200);
            }
            
            while(1);  // åœæ­¢ç³»çµ±
        }
        
        // RGB ç´…ç‡ˆé–ƒçˆ
        ledState = !ledState;
        setRGB(ledState ? 255 : 0, 0, 0);
        delay(100);
    }
    
    // æ­¸é›¶æˆåŠŸ
    Serial.println("âœ“ æ­¸é›¶å®Œæˆï¼");
    beep(1500, 200);
    setRGB(0, 255, 0);  // ç¶ ç‡ˆ
    
    // é¡¯ç¤ºå°±ç·’
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 30, "System Ready!");
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(0, 50, "Press IR to switch");
    u8g2.sendBuffer();
    
    delay(2000);
    systemReady = true;
}

// ==================== ğŸ–¨ï¸ Debug è¼¸å‡º ====================

void printDebug() {
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint < 1000) return;  // æ¯ç§’å°ä¸€æ¬¡
    lastPrint = millis();
    
    Serial.println("===== DEBUG =====");
    Serial.print("IR Mode: ");
    switch (currentIRMode) {
        case IR_MODE_UP:   Serial.println("UP"); break;
        case IR_MODE_DOWN: Serial.println("DOWN"); break;
        case IR_MODE_STOP: Serial.println("AUTO"); break;
    }
    Serial.print("Priority: "); Serial.println(activeCommand.priority);
    Serial.print("Reason: "); Serial.println(activeCommand.reason);
    Serial.print("WantUp: "); Serial.println(activeCommand.wantUp ? "YES" : "NO");
    Serial.print("Speed: "); Serial.print(currentSpeed); Serial.println(" km/h");
    Serial.print("Motor: "); Serial.println(motorOn ? "ON" : "OFF");
    Serial.print("LimitUp: "); Serial.println(digitalRead(LIMIT_UP_PIN) == LOW ? "è§¸ç™¼" : "æœªè§¸ç™¼");
    Serial.print("LimitDown: "); Serial.println(digitalRead(LIMIT_DOWN_PIN) == LOW ? "è§¸ç™¼" : "æœªè§¸ç™¼");
    Serial.println("=================\n");
}

// ==================== âš™ï¸ Setup ====================

void setup() {
    Serial.begin(115200);
    Serial.println("\n======================================");
    Serial.println("  æ™ºæ…§è¼”åŠ©è¼ªç³»çµ± v1.0");
    Serial.println("  IR æ§åˆ¶ï¼šä»»æ„éµé †åºåˆ‡æ›");
    Serial.println("======================================\n");
    
    // 1. åˆå§‹åŒ– I2C
    Wire.begin();
    
    // 2. åˆå§‹åŒ– OLED
    u8g2.begin();
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_ncenB08_tr);
    u8g2.drawStr(0, 30, "Initializing...");
    u8g2.sendBuffer();
    delay(500);
    
    // 3. åˆå§‹åŒ– IR æ¥æ”¶
    IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
    Serial.println("âœ“ IR æ¥æ”¶å™¨å°±ç·’");
    Serial.println("  æŒ‰ä»»æ„éµå¯åˆ‡æ›æ¨¡å¼ï¼š");
    Serial.println("  ç¬¬1æ¬¡ â†’ ä¸Šå‡");
    Serial.println("  ç¬¬2æ¬¡ â†’ ä¸‹é™");
    Serial.println("  ç¬¬3æ¬¡ â†’ è‡ªå‹•");
    Serial.println("  ç¬¬4æ¬¡ â†’ ä¸Šå‡ï¼ˆå¾ªç’°ï¼‰\n");
    
    // 4. åˆå§‹åŒ–è…³ä½
    pinMode(RELAY_PIN, OUTPUT);
    pinMode(LIMIT_UP_PIN, INPUT_PULLUP);
    pinMode(LIMIT_DOWN_PIN, INPUT_PULLUP);
    pinMode(RGB_RED_PIN, OUTPUT);
    pinMode(RGB_GREEN_PIN, OUTPUT);
    pinMode(RGB_BLUE_PIN, OUTPUT);
    pinMode(BUZZER_PIN, OUTPUT);
    
    // 5. ç¢ºä¿é¦¬é”é—œé–‰
    digitalWrite(RELAY_PIN, LOW);
    motorOn = false;
    
    // 6. åˆå§‹åŒ–é€Ÿåº¦ä¸­æ–·
    attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
    Serial.println("âœ“ éœçˆ¾æ„Ÿæ¸¬å™¨å°±ç·’");
    
    // 7. é–‹æ©ŸéŸ³
    beep(1000, 100);
    delay(100);
    beep(1500, 100);
    delay(500);
    
    // 8. è‡ªå‹•æ­¸é›¶
    autoHoming();
    
    Serial.println("\n========== ç³»çµ±å°±ç·’ ==========");
    Serial.println("é–‹å§‹ä¸»å¾ªç’°...\n");
}

// ==================== ğŸ”„ Loop ====================

void loop() {
    // 1. æ›´æ–°é€Ÿåº¦
    currentSpeed = calculateSpeed();
    
    // 2. æ”¶é›†æŒ‡ä»¤
    Command manual = checkManual();   // IR é™æ§
    Command speed = checkSpeed();     // é€Ÿåº¦åˆ¤æ–·
    
    // 3. é¸å‡ºå„ªå…ˆæ¬Šæœ€é«˜çš„æŒ‡ä»¤
    if (manual.priority < speed.priority) {
        activeCommand = manual;
    } else {
        activeCommand = speed;
    }
    
    // 4. åŸ·è¡ŒæŒ‡ä»¤
    executeCommand(activeCommand);
    
    // 5. æ›´æ–°é¡¯ç¤º
    updateDisplay();
    
    // 6. Debug è¼¸å‡ºï¼ˆå¯è¨»è§£æ‰ï¼‰
    // printDebug();
    
    // 7. å»¶é²
    delay(50);  // 20Hz æ›´æ–°é »ç‡
}
```

---

## ğŸ¯ ç¨‹å¼é‹ä½œé‚è¼¯èªªæ˜

### IR æ§åˆ¶é‚è¼¯
```
é–‹æ©Ÿé è¨­ï¼šIR_MODE_STOPï¼ˆè‡ªå‹•æ¨¡å¼ï¼Œç¶ ç‡ˆï¼‰
         â†“
æŒ‰ä»»æ„ IR éµ
         â†“
IR_MODE_UPï¼ˆä¸Šå‡æ¨¡å¼ï¼Œè—ç‡ˆï¼Œé«˜éŸ³å—¶ï¼‰
         â†“
å†æŒ‰ä¸€æ¬¡
         â†“
IR_MODE_DOWNï¼ˆä¸‹é™æ¨¡å¼ï¼Œé»ƒç‡ˆï¼Œä¸­éŸ³å—¶ï¼‰
         â†“
å†æŒ‰ä¸€æ¬¡
         â†“
IR_MODE_STOPï¼ˆè‡ªå‹•æ¨¡å¼ï¼Œç¶ ç‡ˆï¼Œä½éŸ³é•·å—¶ï¼‰
         â†“
å†æŒ‰ä¸€æ¬¡ â†’ å›åˆ° IR_MODE_UPï¼ˆå¾ªç’°ï¼‰
```

### å„ªå…ˆæ¬Šé‚è¼¯
```
æ¯å€‹ loop å¾ªç’°ï¼š

1. æ”¶é›†å…©å€‹æŒ‡ä»¤ï¼š
   - manual = checkManual()  // IR æ§åˆ¶
   - speed = checkSpeed()    // é€Ÿåº¦åˆ¤æ–·

2. æ¯”è¼ƒå„ªå…ˆæ¬Šï¼š
   if (manual.priority < speed.priority):
      activeCommand = manual  // IR å„ªå…ˆ
   else:
      activeCommand = speed   // é€Ÿåº¦æ§åˆ¶

3. åŸ·è¡Œ activeCommand

ç¯„ä¾‹æƒ…å¢ƒï¼š
â”œâ”€ IR åœ¨ã€Œè‡ªå‹•ã€æ¨¡å¼ â†’ manual = {P_IDLE, ...}
â”‚  speed = {P_SPEED, ...} â†’ speed å„ªå…ˆï¼ˆé€Ÿåº¦æ§åˆ¶ï¼‰
â”‚
â”œâ”€ IR åœ¨ã€Œä¸Šå‡ã€æ¨¡å¼ â†’ manual = {P_MANUAL, UP, ...}
â”‚  speed = {P_SPEED, DOWN, ...} â†’ manual å„ªå…ˆï¼ˆIR æ§åˆ¶ï¼‰
â”‚
â””â”€ IR åœ¨ã€Œä¸‹é™ã€æ¨¡å¼ â†’ manual = {P_MANUAL, DOWN, ...}
   åˆ°é”ä¸‹é™ â†’ executeCommand() é˜²å‘†åœæ­¢
```

---

## ğŸ® ä½¿ç”¨èªªæ˜

### é–‹æ©Ÿæµç¨‹
```
1. ä¸Šå‚³ç¨‹å¼
2. æ‰“é–‹ Serial Monitor (115200)
3. çœ‹åˆ°ï¼š
   ======================================
     æ™ºæ…§è¼”åŠ©è¼ªç³»çµ± v1.0
     IR æ§åˆ¶ï¼šä»»æ„éµé †åºåˆ‡æ›
   ======================================
   
4. ç³»çµ±è‡ªå‹•æ­¸é›¶ï¼š
   ========== é–‹å§‹æ­¸é›¶ ==========
   ï¼ˆè¼”åŠ©è¼ªè‡ªç„¶ä¸‹é™ï¼Œç´…ç‡ˆé–ƒçˆï¼‰
   âœ“ æ­¸é›¶å®Œæˆï¼
   ========== ç³»çµ±å°±ç·’ ==========
   
5. OLED é¡¯ç¤ºã€ŒSystem Ready!ã€
6. é€²å…¥ä¸»å¾ªç’°
```

### æ—¥å¸¸æ“ä½œ
```
ã€è‡ªå‹•æ¨¡å¼ã€‘ï¼ˆé è¨­ï¼‰
- é€Ÿåº¦ > 15 km/h â†’ è‡ªå‹•ä¸Šå‡
- é€Ÿåº¦ < 15 km/h â†’ è‡ªå‹•ä¸‹é™
- RGB ç¶ ç‡ˆ

ã€æ‰‹å‹•ä¸Šå‡ã€‘
- æŒ‰ä¸€æ¬¡ IR é™æ§å™¨ä»»æ„éµ
- èœ‚é³´å™¨ï¼šå—¶ï¼ˆé«˜éŸ³ï¼‰
- RGB è—ç‡ˆ
- æŒçºŒä¸Šå‡ï¼ˆç›´åˆ°æŒ‰ä¸‹ä¸€æ¬¡ï¼‰

ã€æ‰‹å‹•ä¸‹é™ã€‘
- å†æŒ‰ä¸€æ¬¡ IR
- èœ‚é³´å™¨ï¼šå—¶ï¼ˆä¸­éŸ³ï¼‰
- RGB é»ƒç‡ˆ
- æŒçºŒä¸‹é™ï¼ˆç›´åˆ°æŒ‰ä¸‹ä¸€æ¬¡ï¼‰

ã€å›åˆ°è‡ªå‹•ã€‘
- å†æŒ‰ä¸€æ¬¡ IR
- èœ‚é³´å™¨ï¼šå—¶å—¶ï¼ˆä½éŸ³é•·ï¼‰
- RGB ç¶ ç‡ˆ
- å›åˆ°é€Ÿåº¦è‡ªå‹•æ§åˆ¶
```

---

## ğŸ“º OLED é¡¯ç¤ºå…§å®¹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Training Wheel v1.0    â”‚ â† æ¨™é¡Œ
â”‚ IR: AUTO               â”‚ â† ç•¶å‰ IR æ¨¡å¼ï¼ˆAUTO/UP/DOWNï¼‰
â”‚ é€Ÿåº¦å¿«-ä¸Šå‡             â”‚ â† ç•¶å‰æŒ‡ä»¤åŸå› 
â”‚ Spd:18.5 km/h          â”‚ â† é€Ÿåº¦
â”‚ MID [ON]               â”‚ â† ç£ç°§ç‹€æ…‹ + é¦¬é”ç‹€æ…‹
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç£ç°§ç‹€æ…‹é¡¯ç¤ºï¼š
- TOP     = åœ¨ä¸Šé™ä½
- BTM     = åœ¨ä¸‹é™ä½
- MID     = åœ¨ä¸­é–“
- TOP BTM = å…©å€‹éƒ½è§¸ç™¼ï¼ˆç•°å¸¸ï¼‰

é¦¬é”ç‹€æ…‹ï¼š
- [ON]  = ç¹¼é›»å™¨é€šé›»ï¼ˆä¸Šå‡ä¸­ï¼‰
- [OFF] = ç¹¼é›»å™¨æ–·é›»ï¼ˆä¸‹é™æˆ–åœæ­¢ï¼‰
