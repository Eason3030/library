// ============================================================================
// è‡ªè¡Œè»Šè¼”åŠ©è¼ªæ™ºèƒ½æ§åˆ¶ç³»çµ± v4.6 - å¾€å¾©å¼è‡´å‹•å™¨å®Œæ•´ä¿®æ­£ç‰ˆ
//
// ã€ç¡¬é«”èªªæ˜ã€‘
// - Gearwell å¾€å¾©å¼ç·šæ€§è‡´å‹•å™¨ï¼ˆ12V 15rpmï¼‰
// - é¦¬é”å–®å‘æŒçºŒæ—‹è½‰ â†’ å‡¸è¼ªæ¨æ†ä¸Šä¸‹å¾€å¾©
// - PWM æ§åˆ¶è½‰é€Ÿï¼ˆON=æ—‹è½‰, OFF=åœæ­¢ï¼‰
// - ç¹¼é›»å™¨åˆ‡æ›æ–¹å‘ï¼ˆHIGH=ä¸Šå‡, LOW=ä¸‹é™ï¼‰
// - ç£ç°§é–‹é—œåµæ¸¬ä¸Š/ä¸‹é™ã€Œç”œèœœé»ã€
//
// ã€v4.6 ä¸»è¦æ”¹é€²ã€‘
// âœ… ä¿®æ­£é™ä½é–å®šé‚è¼¯ - æ™ºèƒ½è§£é–æ©Ÿåˆ¶
// âœ… æ–°å¢é¦¬é”é‹è½‰è¶…æ™‚ä¿è­·ï¼ˆ10ç§’ï¼‰
// âœ… PWM è»Ÿå•Ÿå‹•åŠŸèƒ½ï¼ˆæ¸›å°‘æ©Ÿæ¢°è¡æ“Šï¼‰
// âœ… I2C åŠ é€Ÿè‡³ 400kHz
// âœ… å„ªåŒ–ç‹€æ…‹è½‰æ›é‚è¼¯
// ============================================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <INA226_WE.h>

// ============================================================================
// OLED è¨­å®š
// ============================================================================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ============================================================================
// ç³»çµ±è¨­å®š
// ============================================================================
const bool BUTTON_IS_NC_TYPE = true;
const bool IGNORE_CURRENT_SENSOR = true;
const uint32_t MOTOR_TIMEOUT = 10000;  // ğŸ†• é¦¬é”é‹è½‰è¶…æ™‚ï¼ˆ10ç§’ï¼‰

// ============================================================================
// éŸ³ç¬¦å®šç¾©
// ============================================================================
#define NOTE_C5  523
#define NOTE_E5  659
#define NOTE_G5  784
#define NOTE_C6  1047
#define NOTE_A5  880

// ============================================================================
// MPU6050 è¨­å®š
// ============================================================================
#define MPU_6050 0x68
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B
#define GYRO_XOUT_H  0x43

// ============================================================================
// è…³ä½å®šç¾©
// ============================================================================
const byte BUZZER_PIN = 8;
const byte RELAY_PIN = 11;              // æ–¹å‘åˆ‡æ›ï¼ˆHIGH=ä¸Šå‡, LOW=ä¸‹é™ï¼‰
const byte IR_RECEIVE_PIN = 3;
const byte LIMIT_UP_PIN = 4;            // ä¸Šé™ç£ç°§é–‹é—œ
const byte LIMIT_DOWN_PIN = 10;         // ä¸‹é™ç£ç°§é–‹é—œ
const byte HALL_SPEED_PIN = 2;          // æ¸¬é€Ÿç”¨éœçˆ¾
const byte EMERGENCY_STOP_PIN = 12;
const byte PWM_CONTROL_PIN = 9;         // PWM æ§åˆ¶ï¼ˆå”¯ä¸€å•Ÿåœæ‰‹æ®µï¼‰
const byte SPEED_POT_PIN = A0;

const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;
const bool RGB_COMMON_ANODE = false;

// ============================================================================
// ç³»çµ±ç‹€æ…‹å®šç¾©
// ============================================================================
enum MotionState : byte {
  IDLE,           // åœæ­¢
  MOVING_UP,      // ä¸Šå‡ä¸­
  MOVING_DOWN     // ä¸‹é™ä¸­
};

enum SystemState : byte {
  RUNNING,        // æ­£å¸¸é‹ä½œ
  COOLING_DOWN,   // ç·Šæ€¥åœæ­¢å†·å»
  EMERGENCY       // ç·Šæ€¥ç‹€æ…‹
};

enum RGBColor : byte {
  RGB_OFF, RGB_GREEN, RGB_YELLOW, RGB_BLUE, RGB_RED, RGB_PURPLE
};

// ============================================================================
// å…¨åŸŸè®Šæ•¸
// ============================================================================
INA226_WE ina226;
const float MAX_CURRENT_A = 5.0;
float current_A = 0.0;

MotionState motionState = IDLE;
SystemState currentSystemState = RUNNING;

// é€Ÿåº¦æ¸¬é‡
#define WHEEL_CIRCUMFERENCE 204.2
const float SPEED_THRESHOLD = 10.0;
const uint16_t SPEED_TIMEOUT = 2000;
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t timeBetweenTriggers = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
uint32_t lastSpeedUpdate = 0;

// IMU è³‡æ–™
float compAngleX = 0.0f;
float gyroBiasX = 0.0f;
float accelBiasX = 0.0f;

// å‚¾æ–œä¿è­·
const float SAFE_ANGLE = 20.0f;
const float TILT_SAFE = 12.0f;
const float EMERGENCY_ANGLE = 35.0f;
const uint16_t TILT_TRIGGER_TIME = 500;
const uint16_t AUTO_UP_DELAY = 3000;
uint32_t tiltStartTime = 0;
bool tiltWarning = false;
uint32_t safeStartTime = 0;

// æ§åˆ¶è®Šæ•¸
bool wheelDown = false;         // ç›®æ¨™ç‹€æ…‹
bool manualMode = false;
byte ctrlSrc = 0;               // 0=ç„¡, 1=ç£ç°§, 2=IR, 3=è‡ªå‹•, 4=å‚¾æ–œ

// ğŸ”§ é™ä½é–å®šè®Šæ•¸ï¼ˆä¿®æ­£ç‰ˆï¼‰
bool limitUpLocked = false;     // ä¸Šé™é–å®š
bool limitDownLocked = false;   // ä¸‹é™é–å®š

// ğŸ†• é¦¬é”è¶…æ™‚ä¿è­·
uint32_t motorStartTime = 0;

// æ™‚é–“æ§åˆ¶
uint32_t haltTime = 0;
const uint16_t RESTART_DELAY_MS = 5000;
uint32_t lastPrintTime = 0;
uint32_t lastDisplayTime = 0;
uint32_t lastIRCode = 0;
const uint16_t IR_DELAY = 500;

// éé˜»å¡éŸ³æ•ˆ
uint32_t beepEndTime = 0;
bool isBeeping = false;

// çœ‹é–€ç‹—
uint32_t lastLoopTime = 0;
const uint32_t WATCHDOG_TIMEOUT = 2000;

// ğŸ†• PWM è»Ÿå•Ÿå‹•
int targetPWM = 0;
int currentPWM = 0;
const int PWM_STEP = 8;  // è»Ÿå•Ÿå‹•æ­¥é€²å€¼

// ============================================================================
// RGB LED æ§åˆ¶
// ============================================================================
void setRGB(byte r, byte g, byte b) {
  if (RGB_COMMON_ANODE) {
    analogWrite(RGB_RED_PIN, 255-r);
    analogWrite(RGB_GREEN_PIN, 255-g);
    analogWrite(RGB_BLUE_PIN, 255-b);
  } else {
    analogWrite(RGB_RED_PIN, r);
    analogWrite(RGB_GREEN_PIN, g);
    analogWrite(RGB_BLUE_PIN, b);
  }
}

void setRGBColor(RGBColor c) {
  switch(c) {
    case RGB_OFF: setRGB(0,0,0); break;
    case RGB_GREEN: setRGB(0,255,0); break;
    case RGB_YELLOW: setRGB(255,255,0); break;
    case RGB_BLUE: setRGB(0,0,255); break;
    case RGB_RED: setRGB(255,0,0); break;
    case RGB_PURPLE: setRGB(128,0,255); break;
  }
}

RGBColor decideRGB() {
  if (currentSystemState == COOLING_DOWN || currentSystemState == EMERGENCY) return RGB_RED;
  if (tiltWarning) return RGB_BLUE;
  if (motionState == MOVING_DOWN) return RGB_YELLOW;
  if (motionState == MOVING_UP) return RGB_GREEN;
  if (wheelDown) return RGB_YELLOW;
  return RGB_GREEN;
}

// ============================================================================
// éé˜»å¡éŸ³æ•ˆ
// ============================================================================
void beepStart(uint16_t freq, uint16_t duration) {
  tone(BUZZER_PIN, freq);
  beepEndTime = millis() + duration;
  isBeeping = true;
}

void beepUpdate() {
  if (isBeeping && millis() >= beepEndTime) {
    noTone(BUZZER_PIN);
    isBeeping = false;
  }
}

// ============================================================================
// é€Ÿåº¦è¨ˆç®—
// ============================================================================
void speedInterrupt() {
  uint32_t t = micros();
  if (t - lastSpeedTrigger > 50000) {
    timeBetweenTriggers = t - lastSpeedTrigger;
    lastSpeedTrigger = t;
    newSpeedData = true;
  }
}

float calculateSpeed() {
  if (timeBetweenTriggers == 0) return 0.0;
  float timeInSec = timeBetweenTriggers/1000000.0;
  return (WHEEL_CIRCUMFERENCE/timeInSec)*0.036;
}

// ============================================================================
// MPU6050 å‡½å¼
// ============================================================================
int16_t read16(byte reg) {
  Wire.beginTransmission(MPU_6050);
  Wire.write(reg);
  Wire.endTransmission(false);
  Wire.requestFrom((byte)MPU_6050,(byte)2);
  return (Wire.read()<<8)|Wire.read();
}

void setupMPU() {
  Wire.beginTransmission(MPU_6050);
  Wire.write(PWR_MGMT_1);
  Wire.write(0x00);
  Wire.endTransmission();
  delay(50);
}

void calibrateIMU() {
  float sumAx=0, sumGx=0;
  for(byte i=0; i<50; i++) {
    sumAx += read16(ACCEL_XOUT_H)/16384.0f;
    sumGx += read16(GYRO_XOUT_H)/131.0f;
    delay(5);
  }
  accelBiasX = sumAx/50;
  gyroBiasX = sumGx/50;
}

void readIMU(float &ax, float &gx) {
  ax = read16(ACCEL_XOUT_H)/16384.0f;
  float az = read16(ACCEL_XOUT_H+4)/16384.0f;
  gx = read16(GYRO_XOUT_H)/131.0f;
  gx -= gyroBiasX;
  ax -= accelBiasX;
  float accelAngle = atan2(ax,az)*57.2958f;
  compAngleX = 0.98*(compAngleX+gx*0.01)+0.02*accelAngle;
}

// ============================================================================
// OLED é¡¯ç¤º
// ============================================================================
void showStartupPro() {
  display.clearDisplay();
  display.setTextSize(3);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(15,10);
  display.print(F("BIKE"));
  display.setCursor(10,40);
  display.setTextSize(2);
  display.print(F("v4.6"));
  display.display();
  delay(1000);
}

void drawDashboard() {
  display.clearDisplay();
  
  // è¶…å¤§é€Ÿåº¦é¡¯ç¤º
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(4);
  
  int speedInt = (int)currentSpeed;
  int xPos = (speedInt < 10) ? 40 : 10;
  
  display.setCursor(xPos, 5);
  display.print(speedInt);
  
  // å–®ä½
  display.setTextSize(2);
  display.setCursor(85, 15);
  display.print(F("km"));
  display.setCursor(85, 30);
  display.print(F("/h"));
  
  // åº•éƒ¨è³‡è¨Š
  display.setTextSize(1);
  display.setCursor(2, 54);
  
  // è§’åº¦
  display.print(F("A:"));
  int angleInt = (int)abs(compAngleX);
  if(angleInt < 10) display.print(F(" "));
  display.print(angleInt);
  display.print(F("'"));
  
  // æ–¹å‘
  if(compAngleX > 5) display.print(F("R"));
  else if(compAngleX < -5) display.print(F("L"));
  else display.print(F("-"));
  
  // ç‹€æ…‹
  display.print(F(" |"));
  
  // é‹å‹•ç‹€æ…‹åœ–ç¤º
  if(motionState == MOVING_UP) {
    display.print(F(" ^UP"));
  } else if(motionState == MOVING_DOWN) {
    display.print(F(" vDN"));
  } else {
    display.print(F(" --"));
  }
  
  // è­¦å‘Š
  if(tiltWarning) {
    display.setCursor(100, 54);
    display.print(F("TILT"));
  } else if(currentSystemState != RUNNING) {
    display.setCursor(100, 54);
    display.print(F("LOCK"));
  }
  
  display.display();
}

void drawDetailScreen() {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  
  display.setTextSize(3);
  display.setCursor(5, 5);
  display.print(currentSpeed, 1);
  display.setTextSize(1);
  display.setCursor(90, 15);
  display.print(F("km/h"));
  
  display.setTextSize(2);
  display.setCursor(5, 32);
  display.print(F("A:"));
  display.print(compAngleX, 1);
  
  display.setTextSize(1);
  display.setCursor(5, 54);
  
  // ç‹€æ…‹æ–‡å­—
  if(motionState == MOVING_UP) display.print(F("MOVING UP  "));
  else if(motionState == MOVING_DOWN) display.print(F("MOVING DOWN"));
  else display.print(F("STOPPED    "));
  
  // PWM å€¼
  display.setCursor(90, 54);
  display.print(currentPWM);
  
  display.display();
}

// ============================================================================
// ç´…å¤–ç·šæ§åˆ¶ï¼ˆä¿®æ­£ç‰ˆ - ç§»é™¤æ‰‹å‹•è§£é–ï¼‰
// ============================================================================
void handleIRCommand(uint32_t code) {
  if(millis() - lastIRCode > IR_DELAY) {
    lastIRCode = millis();
    
    // åˆ‡æ›ç›®æ¨™ç‹€æ…‹
    wheelDown = !wheelDown;
    manualMode = true;
    ctrlSrc = 2;
    
    beepStart(NOTE_A5, 50);
    Serial.print(F("IR: Target "));
    Serial.println(wheelDown ? F("DOWN") : F("UP"));
    
    // âœ… æ™ºèƒ½è§£é–æœƒè‡ªå‹•è™•ç†ï¼Œä¸éœ€è¦æ‰‹å‹•è§£é–
  }
}

// ============================================================================
// ğŸ†• PWM è»Ÿå•Ÿå‹•å‡½å¼
// ============================================================================
void smoothPWM() {
  if(currentPWM < targetPWM) {
    currentPWM = min(currentPWM + PWM_STEP, targetPWM);
  } else if(currentPWM > targetPWM) {
    currentPWM = max(currentPWM - PWM_STEP, targetPWM);
  }
  
  analogWrite(PWM_CONTROL_PIN, currentPWM);
}

// ============================================================================
// ğŸ”§ é‹å‹•æ§åˆ¶æ ¸å¿ƒï¼ˆå¾€å¾©å¼è‡´å‹•å™¨å®Œæ•´ä¿®æ­£ç‰ˆ v4.6ï¼‰
// ============================================================================
void executeMotion() {
  // 1ï¸âƒ£ è®€å–ç£ç°§é–‹é—œç‹€æ…‹
  bool limitUpTriggered = (digitalRead(LIMIT_UP_PIN) == LOW);
  bool limitDownTriggered = (digitalRead(LIMIT_DOWN_PIN) == LOW);
  
  // 2ï¸âƒ£ æ™ºèƒ½è§£é–ï¼šç•¶ç›®æ¨™æ–¹å‘æ”¹è®Šæ™‚ï¼Œè‡ªå‹•è§£é™¤å°æ‡‰çš„é™ä½é–å®š
  if (wheelDown && limitUpLocked) {
    limitUpLocked = false;
    Serial.println(F("ğŸ”“ Auto-unlock UP (targetâ†’DOWN)"));
  }
  
  if (!wheelDown && limitDownLocked) {
    limitDownLocked = false;
    Serial.println(F("ğŸ”“ Auto-unlock DOWN (targetâ†’UP)"));
  }
  
  // 3ï¸âƒ£ é¦¬é”é‹è½‰è¶…æ™‚ä¿è­·
  if(motionState != IDLE) {
    if(motorStartTime == 0) {
      motorStartTime = millis();
    }
    
    if(millis() - motorStartTime > MOTOR_TIMEOUT) {
      Serial.println(F(""));
      Serial.println(F("âš ï¸ ============================="));
      Serial.println(F("âš ï¸  MOTOR TIMEOUT! (10 sec)"));
      Serial.println(F("âš ï¸  ç£ç°§é–‹é—œå¯èƒ½æ•…éšœæˆ–æœªå°æº–"));
      Serial.println(F("âš ï¸ ============================="));
      
      currentSystemState = EMERGENCY;
      motionState = IDLE;
      targetPWM = 0;
      beepStart(NOTE_A5, 300);
      motorStartTime = 0;
      return;
    }
  } else {
    motorStartTime = 0;  // é‡ç½®è¨ˆæ™‚å™¨
  }
  
  // 4ï¸âƒ£ ç‹€æ…‹æ©Ÿæ ¸å¿ƒé‚è¼¯
  switch(motionState) {
    
    // ========== IDLEï¼šåœæ­¢ç‹€æ…‹ ==========
    case IDLE:
      if(currentSystemState == RUNNING) {
        
        // éœ€è¦ä¸‹é™ ä¸” (æœªè§¸ç™¼ä¸‹é™ ä¸” ä¸‹é™æœªé–å®š)
        if(wheelDown && !limitDownTriggered && !limitDownLocked) {
          digitalWrite(RELAY_PIN, LOW);   // è¨­å®šä¸‹é™æ–¹å‘
          motionState = MOVING_DOWN;
          Serial.println(F(">>> START DOWN"));
        }
        
        // éœ€è¦ä¸Šå‡ ä¸” (æœªè§¸ç™¼ä¸Šé™ ä¸” ä¸Šé™æœªé–å®š)
        else if(!wheelDown && !limitUpTriggered && !limitUpLocked) {
          digitalWrite(RELAY_PIN, HIGH);  // è¨­å®šä¸Šå‡æ–¹å‘
          motionState = MOVING_UP;
          Serial.println(F(">>> START UP"));
        }
      }
      targetPWM = 0;  // åœæ­¢æ™‚ PWM = 0
      break;
      
    // ========== MOVING_UPï¼šä¸Šå‡ä¸­ ==========
    case MOVING_UP:
      // åˆ°é”ä¸Šé™
      if(limitUpTriggered) {
        limitUpLocked = true;  // é–å®šä¸Šé™
        motionState = IDLE;
        ctrlSrc = 1;
        beepStart(NOTE_C6, 50);
        Serial.println(F("<<< UP LIMIT REACHED âœ“"));
      }
      // ç›®æ¨™æ”¹è®Šï¼ˆä½¿ç”¨è€…è¦æ±‚ä¸‹é™ï¼‰
      else if(wheelDown) {
        motionState = IDLE;
        Serial.println(F("<<< UP ABORT (target changed)"));
      }
      // æ­£å¸¸é‹è½‰
      else {
        int potValue = analogRead(SPEED_POT_PIN);
        targetPWM = map(potValue, 0, 1023, 120, 255);
      }
      break;
      
    // ========== MOVING_DOWNï¼šä¸‹é™ä¸­ ==========
    case MOVING_DOWN:
      // åˆ°é”ä¸‹é™
      if(limitDownTriggered) {
        limitDownLocked = true;  // é–å®šä¸‹é™
        motionState = IDLE;
        ctrlSrc = 1;
        beepStart(NOTE_G5, 50);
        Serial.println(F("<<< DOWN LIMIT REACHED âœ“"));
      }
      // ç›®æ¨™æ”¹è®Šï¼ˆä½¿ç”¨è€…è¦æ±‚ä¸Šå‡ï¼‰
      else if(!wheelDown) {
        motionState = IDLE;
        Serial.println(F("<<< DOWN ABORT (target changed)"));
      }
      // æ­£å¸¸é‹è½‰
      else {
        int potValue = analogRead(SPEED_POT_PIN);
        targetPWM = map(potValue, 0, 1023, 120, 255);
      }
      break;
  }
  
  // 5ï¸âƒ£ ç·Šæ€¥åœæ­¢å¼·åˆ¶è¦†è“‹
  if(currentSystemState != RUNNING) {
    motionState = IDLE;
    targetPWM = 0;
  }
  
  // 6ï¸âƒ£ è¼¸å‡º PWMï¼ˆè»Ÿå•Ÿå‹•ç‰ˆæœ¬ï¼‰
  smoothPWM();
}

// ============================================================================
// Setup
// ============================================================================
void setup() {
  Serial.begin(115200);
  delay(100);
  
  Wire.begin();
  Wire.setClock(400000);  // ğŸ†• I2C åŠ é€Ÿè‡³ 400kHz
  
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(LIMIT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_DOWN_PIN, INPUT_PULLUP);
  pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);
  pinMode(PWM_CONTROL_PIN, OUTPUT);
  pinMode(RGB_RED_PIN, OUTPUT);
  pinMode(RGB_GREEN_PIN, OUTPUT);
  pinMode(RGB_BLUE_PIN, OUTPUT);
  
  digitalWrite(RELAY_PIN, LOW);
  analogWrite(PWM_CONTROL_PIN, 0);
  setRGBColor(RGB_OFF);
  
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
  
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("OLED Fail"));
    while(1);
  }
  
  ina226.init();
  setupMPU();
  calibrateIMU();
  
  showStartupPro();
  beepStart(NOTE_C6, 100);
  
  Serial.println(F(""));
  Serial.println(F("===================================="));
  Serial.println(F("  ğŸš´ BIKE ASSIST v4.6 READY ğŸš´"));
  Serial.println(F("  å¾€å¾©å¼è‡´å‹•å™¨å®Œæ•´ä¿®æ­£ç‰ˆ"));
  Serial.println(F("===================================="));
  Serial.println(F("âœ… æ™ºèƒ½è§£é–æ©Ÿåˆ¶"));
  Serial.println(F("âœ… é¦¬é”è¶…æ™‚ä¿è­· (10ç§’)"));
  Serial.println(F("âœ… PWM è»Ÿå•Ÿå‹•"));
  Serial.println(F("âœ… I2C 400kHz åŠ é€Ÿ"));
  Serial.println(F("===================================="));
  Serial.println(F(""));
  
  lastLoopTime = millis();
}

// ============================================================================
// Loop - ä¸»ç¨‹å¼
// ============================================================================
void loop() {
  uint32_t currentMillis = millis();
  
  // ========== çœ‹é–€ç‹—ï¼ˆé˜²ç•¶æ©Ÿæ ¸å¿ƒæ©Ÿåˆ¶ï¼‰==========
  if(currentMillis - lastLoopTime > WATCHDOG_TIMEOUT) {
    Serial.println(F(""));
    Serial.println(F("!!!!!!!!!!!!!!!!!!!!!!!!"));
    Serial.println(F("!!! WATCHDOG RESET !!!"));
    Serial.println(F("!!!!!!!!!!!!!!!!!!!!!!!!"));
    
    // å¼·åˆ¶å®‰å…¨ç‹€æ…‹
    motionState = IDLE;
    currentSystemState = RUNNING;
    targetPWM = 0;
    currentPWM = 0;
    analogWrite(PWM_CONTROL_PIN, 0);
    digitalWrite(RELAY_PIN, LOW);
    
    // é‡ç½®æ§åˆ¶è®Šæ•¸
    tiltWarning = false;
    manualMode = false;
    motorStartTime = 0;
    
    // ç™¼å‡ºè­¦å‘ŠéŸ³
    beepStart(NOTE_A5, 300);
  }
  lastLoopTime = currentMillis;
  
  // ========== éé˜»å¡éŸ³æ•ˆæ›´æ–° ==========
  beepUpdate();
  
  // ========== è®€å–æ„Ÿæ¸¬å™¨ ==========
  float ax, gx;
  readIMU(ax, gx);
  
  current_A = ina226.getCurrent_A();
  if(isnan(current_A)) current_A = 0.0;
  
  if(newSpeedData) {
    currentSpeed = calculateSpeed();
    newSpeedData = false;
    lastSpeedUpdate = millis();
  }
  
  if(millis() - lastSpeedUpdate > SPEED_TIMEOUT) {
    currentSpeed = 0.0;
  }
  
  // ========== ç´…å¤–ç·š ==========
  if(IrReceiver.decode()) {
    handleIRCommand(IrReceiver.decodedIRData.decodedRawData);
    IrReceiver.resume();
  }
  
  // ========== ç·Šæ€¥åœæ­¢æª¢æŸ¥ ==========
  bool emergencyStop = false;
  if(!IGNORE_CURRENT_SENSOR && current_A > MAX_CURRENT_A) {
    emergencyStop = true;
  }
  
  if(emergencyStop && currentSystemState == RUNNING) {
    currentSystemState = COOLING_DOWN;
    haltTime = currentMillis;
    motionState = IDLE;
    targetPWM = 0;
    currentPWM = 0;
    analogWrite(PWM_CONTROL_PIN, 0);
    beepStart(NOTE_C6, 200);
    Serial.println(F("âš ï¸ EMERGENCY! Over-current"));
  }
  
  // ========== å†·å»æ¢å¾© ==========
  if(currentSystemState == COOLING_DOWN) {
    if(currentMillis - haltTime >= RESTART_DELAY_MS) {
      currentSystemState = RUNNING;
      Serial.println(F("âœ“ RECOVERED from cooling"));
    }
  }
  
  // ========== å‚¾æ–œä¿è­· ==========
  if(currentSystemState == RUNNING) {
    if(abs(compAngleX) > EMERGENCY_ANGLE) {
      currentSystemState = EMERGENCY;
      motionState = IDLE;
      targetPWM = 0;
      wheelDown = true;  // å¼·åˆ¶ä¸‹é™
      Serial.println(F("ğŸš¨ EMERGENCY TILT!"));
    }
    else if(abs(compAngleX) > SAFE_ANGLE) {
      if(tiltStartTime == 0) tiltStartTime = millis();
      
      if(!tiltWarning && (millis() - tiltStartTime >= TILT_TRIGGER_TIME)) {
        tiltWarning = true;
        wheelDown = true;
        manualMode = false;
        ctrlSrc = 4;
        Serial.println(F("âš ï¸ TILT WARNING"));
      }
    } else {
      tiltStartTime = 0;
      
      if(tiltWarning && abs(compAngleX) < TILT_SAFE) {
        if(safeStartTime == 0) safeStartTime = millis();
        
        if(millis() - safeStartTime >= AUTO_UP_DELAY) {
          tiltWarning = false;
          if(!manualMode) wheelDown = false;
          Serial.println(F("âœ“ TILT SAFE"));
        }
      } else {
        safeStartTime = 0;
      }
    }
  }
  
  // ========== è‡ªå‹•é€Ÿåº¦æ§åˆ¶ ==========
  if(currentSystemState == RUNNING && !manualMode && !tiltWarning) {
    if(currentSpeed < SPEED_THRESHOLD && !wheelDown) {
      wheelDown = true;
      ctrlSrc = 3;
    } else if(currentSpeed >= SPEED_THRESHOLD && wheelDown) {
      wheelDown = false;
      ctrlSrc = 3;
    }
  }
  
  // ========== åŸ·è¡Œé‹å‹•æ§åˆ¶ ==========
  executeMotion();
  
  // ========== RGB é¡¯ç¤º ==========
  setRGBColor(decideRGB());
  
  // ========== OLED æ›´æ–° ==========
  if(millis() - lastDisplayTime > 200) {
    lastDisplayTime = millis();
    
    int displayMode = (millis() / 5000) % 2;
    if(displayMode == 0) drawDashboard();
    else drawDetailScreen();
  }
  
  // ========== åºåˆ—åŸ è¼¸å‡º ==========
  if(millis() - lastPrintTime > 1000) {
    lastPrintTime = millis();
    
    // ä¸»è¦ç‹€æ…‹
    Serial.print(F("Sys:"));
    if(currentSystemState == RUNNING) Serial.print(F("RUN"));
    else if(currentSystemState == COOLING_DOWN) Serial.print(F("COOL"));
    else Serial.print(F("EMRG"));
    
    Serial.print(F(" |Motion:"));
    if(motionState == MOVING_UP) Serial.print(F("^UP^"));
    else if(motionState == MOVING_DOWN) Serial.print(F("vDNv"));
    else Serial.print(F("IDLE"));
    
    Serial.print(F(" |Target:"));
    Serial.print(wheelDown ? F("DN") : F("UP"));
    
    // ç£ç°§ç‹€æ…‹èˆ‡é–å®šç‹€æ…‹
    Serial.print(F(" |LimUP:"));
    Serial.print(digitalRead(LIMIT_UP_PIN) == LOW ? F("ON") : F("--"));
    if(limitUpLocked) Serial.print(F("[L]"));
    
    Serial.print(F(" |LimDN:"));
    Serial.print(digitalRead(LIMIT_DOWN_PIN) == LOW ? F("ON") : F("--"));
    if(limitDownLocked) Serial.print(F("[L]"));
    
    // é€Ÿåº¦èˆ‡è§’åº¦
    Serial.print(F(" |Spd:"));
    Serial.print(currentSpeed, 1);
    Serial.print(F(" |Ang:"));
    Serial.print(compAngleX, 1);
    
    // PWM è¼¸å‡ºï¼ˆè»Ÿå•Ÿå‹•ç‰ˆæœ¬ï¼‰
    Serial.print(F(" |PWM:"));
    Serial.print(currentPWM);
    Serial.print(F("/"));
    Serial.print(targetPWM);
    
    // é›»æµ
    Serial.print(F(" |I:"));
    Serial.print(current_A, 2);
    Serial.print(F("A"));
    
    // é¦¬é”é‹è½‰æ™‚é–“
    if(motorStartTime > 0) {
      Serial.print(F(" |MotT:"));
      Serial.print((millis() - motorStartTime)/1000);
      Serial.print(F("s"));
    }
    
    // è­¦å‘Šæ¨™è¨˜
    if(tiltWarning) Serial.print(F(" [TILT!]"));
    if(manualMode) Serial.print(F(" [MANUAL]"));
    
    // æ§åˆ¶ä¾†æº
    Serial.print(F(" Src:"));
    switch(ctrlSrc) {
      case 0: Serial.print(F("--")); break;
      case 1: Serial.print(F("LIM")); break;
      case 2: Serial.print(F("IR")); break;
      case 3: Serial.print(F("AUTO")); break;
      case 4: Serial.print(F("TILT")); break;
    }
    
    Serial.println();
  }
  
  // å°å»¶é²é˜²æ­¢ CPU æ»¿è¼‰
  delay(5);
}
