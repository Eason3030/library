// ============================================================================
// 雙致動器智能控制系統 v7.1 - 完整整合修正版
// 整合：極速停止邏輯 + A0 即時調速 + 完整 OLED/IMU/同步控制邏輯
// ============================================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <INA226_WE.h>
#include <avr/wdt.h>

// ============================================================================
// OLED 螢幕設定
// ============================================================================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ============================================================================
// 系統設定
// ============================================================================
const bool BUTTON_IS_NC_TYPE = true;
const bool IGNORE_CURRENT_SENSOR = false;
#define SINGLE_ACTUATOR_TEST true

// ============================================================================
// 音符定義
// ============================================================================
#define NOTE_C5  523
#define NOTE_E5  659
#define NOTE_G5  784
#define NOTE_C6  1047
#define NOTE_A5  880

// ============================================================================
// MPU6050 設定
// ============================================================================
#define MPU_6050 0x69
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B
#define GYRO_XOUT_H  0x43

// ============================================================================
// 腳位定義
// ============================================================================
const byte BUZZER_PIN = 8;
const byte IR_RECEIVE_PIN = 3;
const byte PWM_PIN = 9;  

const byte LIMIT_LEFT_UP_PIN = 52;
const byte LIMIT_LEFT_DOWN_PIN = 53;
const byte LIMIT_RIGHT_UP_PIN = 13;
const byte LIMIT_RIGHT_DOWN_PIN = A1;

const byte HALL_SPEED_PIN = 2;
const byte EMERGENCY_STOP_PIN = 12;
const byte RESET_BUTTON_PIN = A2;
const byte SPEED_CONTROL_PIN = A0;

const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;
const bool RGB_COMMON_ANODE = false;

// ============================================================================
// 狀態定義
// ============================================================================
enum SystemState : byte {
  STATE_INIT,           
  STATE_STANDBY,        
  STATE_RISING,         
  STATE_UP,             
  STATE_FALLING,        
  STATE_EMERGENCY_STOP, 
  STATE_OVERCURRENT,    
  STATE_COOLING         
};

enum ControlPriority : byte {
  PRIORITY_EMERGENCY = 0,
  PRIORITY_SAFETY_DOWN = 1,
  PRIORITY_COOLING = 2,
  PRIORITY_MANUAL = 3,
  PRIORITY_AUTO = 4
};

enum RGBColor : byte {
  RGB_OFF, RGB_GREEN, RGB_YELLOW, RGB_BLUE, RGB_RED, RGB_PURPLE, RGB_CYAN
};

struct ActuatorStatus {
  bool upLimitPressed;
  bool downLimitPressed;
  uint32_t lastChangeTime;
  uint16_t debounceTime;
};

ActuatorStatus actuator1 = {false, false, 0, 50};
ActuatorStatus actuator2 = {false, false, 0, 50};

// ============================================================================
// 全域變數
// ============================================================================
INA226_WE ina226;
const float MAX_CURRENT_A = 3.0;
float current_A = 0.0;

SystemState currentState = STATE_INIT;
SystemState previousState = STATE_INIT;
ControlPriority currentPriority = PRIORITY_AUTO;

bool bothAtBottom = false;
bool bothAtTop = false;
unsigned long syncTimeout = 0;
const unsigned long SYNC_TIMEOUT_MS = 3000;

int pwmSpeedUp = 200;
int pwmSpeedDown = 180;
unsigned long lastSpeedRead = 0;

#define WHEEL_CIRCUMFERENCE 204.2
const uint16_t SPEED_TIMEOUT = 2000;
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t timeBetweenTriggers = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
uint32_t lastSpeedUpdate = 0;

float compAngleX = 0.0f;
float gyroBiasX = 0.0f;
float accelBiasX = 0.0f;
uint32_t lastIMUTime = 0;
bool i2cHealthy = true;

const float SAFE_ANGLE = 10.0f;
const float TILT_SAFE = 5.0f;
const float EMERGENCY_ANGLE = 15.0f;
const uint16_t TILT_TRIGGER_TIME = 500;
const uint16_t AUTO_UP_DELAY = 3000;
uint32_t tiltStartTime = 0;
bool tiltWarning = false;
uint32_t safeStartTime = 0;

const byte SPEED_STABLE_COUNT = 2; // 優化靈敏度
byte speedLowCount = 0;
byte speedHighCount = 0;
const float SPEED_UP_THRESHOLD = 20.0;
const float SPEED_DOWN_THRESHOLD = 15.0;
const float SPEED_MIN_SAFE = 5.0;

bool wheelDown = true;
bool manualMode = false;
byte ctrlSrc = 0;
bool emergencyStopPressed = false;
bool manualResetConfirmed = false;
uint32_t haltTime = 0;
bool overCurrentDetected = false;
bool irCommandReceived = false;

uint32_t lastPrintTime = 0;
uint32_t lastDisplayTime = 0;
uint32_t lastIRCode = 0;
const uint16_t IR_DELAY = 500;

uint32_t beepEndTime = 0;
bool isBeeping = false;

// ============================================================================
// 基礎功能
// ============================================================================
void stopAllPWM() {
  analogWrite(PWM_PIN, 0);
  digitalWrite(PWM_PIN, LOW);
}

void speedInterrupt() {
  uint32_t t = micros();
  if (t - lastSpeedTrigger > 40000) {
    timeBetweenTriggers = t - lastSpeedTrigger;
    lastSpeedTrigger = t;
    newSpeedData = true;
  }
}

void setRGB(byte r, byte g, byte b) {
  if (RGB_COMMON_ANODE) {
    analogWrite(RGB_RED_PIN, 255-r);
    analogWrite(RGB_GREEN_PIN, 255-g);
    analogWrite(RGB_BLUE_PIN, 255-b);
  } else {
    analogWrite(RGB_RED_PIN, r);
    analogWrite(RGB_GREEN_PIN, g);
    analogWrite(RGB_BLUE_PIN, b);
  }
}

void setRGBColor(RGBColor c) {
  switch(c) {
    case RGB_OFF: setRGB(0,0,0); break;
    case RGB_GREEN: setRGB(0,255,0); break;
    case RGB_YELLOW: setRGB(255,255,0); break;
    case RGB_BLUE: setRGB(0,0,255); break;
    case RGB_RED: setRGB(255,0,0); break;
    case RGB_PURPLE: setRGB(128,0,255); break;
    case RGB_CYAN: setRGB(0,255,255); break;
  }
}

RGBColor decideRGB() {
  switch(currentPriority) {
    case PRIORITY_EMERGENCY:
    case PRIORITY_COOLING: return RGB_RED;
    case PRIORITY_SAFETY_DOWN: return RGB_BLUE;
    case PRIORITY_MANUAL: return RGB_PURPLE;
    default:
      if (currentState == STATE_RISING) return RGB_GREEN;
      if (currentState == STATE_FALLING) return RGB_YELLOW;
      return wheelDown ? RGB_YELLOW : RGB_GREEN;
  }
}

void beepStart(uint16_t freq, uint16_t duration) {
  tone(BUZZER_PIN, freq);
  beepEndTime = millis() + duration;
  isBeeping = true;
}

void beepUpdate() {
  if (isBeeping && millis() >= beepEndTime) {
    noTone(BUZZER_PIN);
    isBeeping = false;
  }
}

float calculateSpeed() {
  if (timeBetweenTriggers == 0) return 0.0;
  return (WHEEL_CIRCUMFERENCE / (timeBetweenTriggers / 1000000.0)) * 0.036;
}

// ============================================================================
// MPU6050 函式
// ============================================================================
int16_t safeRead16(byte reg) {
  Wire.beginTransmission(MPU_6050);
  Wire.write(reg);
  if(Wire.endTransmission(false) != 0) { i2cHealthy = false; return 0; }
  Wire.requestFrom((byte)MPU_6050, (byte)2);
  uint32_t start = millis();
  while (Wire.available() < 2) { if (millis() - start > 10) { i2cHealthy = false; return 0; } }
  i2cHealthy = true;
  return (Wire.read()<<8)|Wire.read();
}

void setupMPU() {
  Wire.beginTransmission(MPU_6050);
  Wire.write(PWR_MGMT_1);
  Wire.write(0x00);
  Wire.endTransmission();
  delay(50);
}

void calibrateIMU() {
  Serial.println(F("校準 IMU..."));
  float sumAx=0, sumGx=0;
  for(byte i=0; i<50; i++) {
    sumAx += safeRead16(ACCEL_XOUT_H)/16384.0f;
    sumGx += safeRead16(GYRO_XOUT_H)/131.0f;
    delay(5);
  }
  accelBiasX = sumAx/50;
  gyroBiasX = sumGx/50;
  Serial.println(F("IMU 校準完成"));
}

void readIMU() {
  if(!i2cHealthy) return;
  uint32_t now = micros();
  float dt = (now - lastIMUTime) / 1000000.0;
  lastIMUTime = now;
  if (dt > 0.1) dt = 0.01;
  float ax = safeRead16(ACCEL_XOUT_H) / 16384.0f - accelBiasX;
  float az = safeRead16(ACCEL_XOUT_H + 4) / 16384.0f;
  float gx = safeRead16(GYRO_XOUT_H) / 131.0f - gyroBiasX;
  float accelAngle = atan2(ax, az) * 57.2958f;
  compAngleX = 0.98 * (compAngleX + gx * dt) + 0.02 * accelAngle;
}

// ============================================================================
// 限位與控制 (植入極速停止邏輯)
// ============================================================================
void updateLimitSwitches() {
  // 移除延遲，直接讀取硬體狀態
  actuator1.upLimitPressed = (digitalRead(LIMIT_LEFT_UP_PIN) == LOW);
  actuator1.downLimitPressed = (digitalRead(LIMIT_LEFT_DOWN_PIN) == LOW);
  actuator2.upLimitPressed = (digitalRead(LIMIT_RIGHT_UP_PIN) == LOW);
  actuator2.downLimitPressed = (digitalRead(LIMIT_RIGHT_DOWN_PIN) == LOW);

#if SINGLE_ACTUATOR_TEST
  bothAtBottom = actuator1.downLimitPressed;
  bothAtTop    = actuator1.upLimitPressed;
#else
  bothAtBottom = actuator1.downLimitPressed && actuator2.downLimitPressed;
  bothAtTop = actuator1.upLimitPressed && actuator2.upLimitPressed;
#endif
}

void moveUp() {
  if (bothAtTop) stopAllPWM();
  else analogWrite(PWM_PIN, pwmSpeedUp);
}

void moveDown() {
  if (bothAtBottom) stopAllPWM();
  else analogWrite(PWM_PIN, pwmSpeedDown);
}

void readSpeedControl() {
  // A0 即時調速植入
  int speedControlValue = analogRead(SPEED_CONTROL_PIN);
  pwmSpeedUp = map(speedControlValue, 0, 1023, 50, 255);
  pwmSpeedDown = map(speedControlValue, 0, 1023, 50, 220);
  pwmSpeedUp = constrain(pwmSpeedUp, 50, 255);
  pwmSpeedDown = constrain(pwmSpeedDown, 50, 220);
}

void readMotorCurrent() {
  if(IGNORE_CURRENT_SENSOR) { current_A = 0.0; }
  else {
    float tempCurrent = ina226.getCurrent_A();
    current_A = (isnan(tempCurrent) || tempCurrent < -1.0 || tempCurrent > 10.0) ? 0.0 : abs(tempCurrent);
  }
}

// ============================================================================
// 邏輯決策與狀態機
// ============================================================================
void decidePriority() {
  if (emergencyStopPressed || (!IGNORE_CURRENT_SENSOR && current_A > MAX_CURRENT_A) || (abs(compAngleX) > EMERGENCY_ANGLE)) {
    currentPriority = PRIORITY_EMERGENCY; return;
  }
  if (tiltWarning) { currentPriority = PRIORITY_SAFETY_DOWN; return; }
  if (!wheelDown && currentSpeed < SPEED_DOWN_THRESHOLD && speedLowCount >= SPEED_STABLE_COUNT) {
    currentPriority = PRIORITY_SAFETY_DOWN; return;
  }
  if (currentState == STATE_COOLING) { currentPriority = PRIORITY_COOLING; return; }
  if (manualMode) { currentPriority = PRIORITY_MANUAL; return; }
  currentPriority = PRIORITY_AUTO;
}

void executeByPriority() {
  switch(currentPriority) {
    case PRIORITY_EMERGENCY:
      wheelDown = true; manualMode = false; ctrlSrc = 0;
      if(currentState != STATE_COOLING && currentState != STATE_EMERGENCY_STOP) {
        previousState = currentState; currentState = STATE_EMERGENCY_STOP; haltTime = millis(); beepStart(NOTE_C6, 300);
      }
      break;
    case PRIORITY_SAFETY_DOWN: wheelDown = true; manualMode = false; ctrlSrc = 4; break;
    case PRIORITY_COOLING: wheelDown = true; manualMode = false; ctrlSrc = 0; break;
    case PRIORITY_MANUAL: ctrlSrc = 2; break;
    case PRIORITY_AUTO:
      if(currentSpeed >= SPEED_UP_THRESHOLD && speedHighCount >= SPEED_STABLE_COUNT) {
        if(wheelDown) { wheelDown = false; ctrlSrc = 3; }
      } else if(currentSpeed < SPEED_DOWN_THRESHOLD && speedLowCount >= SPEED_STABLE_COUNT) {
        if(!wheelDown) { wheelDown = true; ctrlSrc = 3; }
      }
      break;
  }
}

void handleStateMachine() {
  // --- 【最高優先權：硬體限位即時切斷】 ---
  if (bothAtTop && currentState == STATE_RISING) { stopAllPWM(); currentState = STATE_UP; return; }
  if (bothAtBottom && (currentState == STATE_FALLING || currentState == STATE_INIT)) { stopAllPWM(); currentState = STATE_STANDBY; return; }

  switch (currentState) {
    case STATE_INIT:
      if (bothAtBottom) { stopAllPWM(); currentState = STATE_STANDBY; }
      else moveDown();
      break;
    case STATE_STANDBY:
      stopAllPWM();
      if (!wheelDown && currentSpeed >= SPEED_UP_THRESHOLD) currentState = STATE_RISING;
      break;
    case STATE_RISING:
      if (bothAtTop) { stopAllPWM(); currentState = STATE_UP; }
      else if (currentSpeed < SPEED_MIN_SAFE || wheelDown) currentState = STATE_FALLING;
      else moveUp();
      break;
    case STATE_UP:
      stopAllPWM();
      if (currentSpeed < SPEED_MIN_SAFE || wheelDown) currentState = STATE_FALLING;
      break;
    case STATE_FALLING:
      if (bothAtBottom) { stopAllPWM(); currentState = STATE_STANDBY; }
      else if (!wheelDown && currentSpeed >= SPEED_UP_THRESHOLD) currentState = STATE_RISING;
      else moveDown();
      break;
    case STATE_EMERGENCY_STOP:
      stopAllPWM();
      if (!emergencyStopPressed && digitalRead(RESET_BUTTON_PIN) == LOW) currentState = STATE_INIT;
      break;
    case STATE_OVERCURRENT:
      stopAllPWM();
      if (current_A < MAX_CURRENT_A * 0.8) currentState = previousState;
      break;
    case STATE_COOLING:
      stopAllPWM();
      if (digitalRead(RESET_BUTTON_PIN) == LOW) currentState = STATE_INIT;
      break;
  }
}

// ============================================================================
// 紅外線與 OLED
// ============================================================================
void handleIRCommand(uint32_t code) {
  if(millis() - lastIRCode < IR_DELAY) return;
  lastIRCode = millis();
  if(currentPriority < PRIORITY_MANUAL) return;
  wheelDown = !wheelDown; manualMode = true; ctrlSrc = 2; irCommandReceived = true;
  beepStart(NOTE_A5, 50);
}

void drawDashboard() {
  display.clearDisplay();
  display.setTextSize(3); display.setCursor(0, 0); display.print((int)currentSpeed);
  display.setTextSize(1); display.setCursor(45, 0); display.print(F("km/h"));
  display.setTextSize(2); display.setCursor(0, 24); display.print(compAngleX, 1); display.print(F("'"));
  display.setTextSize(1); display.setCursor(65, 0); display.print(F("P:"));
  switch(currentPriority) {
    case PRIORITY_EMERGENCY: display.print(F("EMG")); break;
    case PRIORITY_AUTO: display.print(F("AUT")); break;
    default: display.print(F("OTH")); break;
  }
  display.setCursor(65, 10); display.print(F("S:")); display.print(currentState);
  display.setCursor(65, 20); display.print(F("I:")); display.print(current_A, 1);
  display.setCursor(65, 30); display.print(F("PWM:")); display.print(pwmSpeedUp);
  display.display();
}

// ============================================================================
// Setup & Loop
// ============================================================================
void setup() {
  Serial.begin(115200);
  pinMode(PWM_PIN, OUTPUT);
  stopAllPWM();
  pinMode(LIMIT_LEFT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_LEFT_DOWN_PIN, INPUT_PULLUP);
  pinMode(LIMIT_RIGHT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_RIGHT_DOWN_PIN, INPUT_PULLUP);
  pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);
  pinMode(SPEED_CONTROL_PIN, INPUT);
  
  attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
  
  Wire.begin();
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  ina226.init();
  setupMPU();
  
  currentState = STATE_INIT;
}

void loop() {
  // 1. 即時更新限位與 A0 速度 (最高優先權)
  updateLimitSwitches();
  readSpeedControl();

  // 2. 速度更新
  if(newSpeedData) {
    currentSpeed = calculateSpeed();
    newSpeedData = false;
    lastSpeedUpdate = millis();
  }
  if(millis() - lastSpeedUpdate > SPEED_TIMEOUT) currentSpeed = 0.0;

  // 3. 速度防抖
  if(currentSpeed >= SPEED_UP_THRESHOLD) {
    speedHighCount = min(speedHighCount + 1, SPEED_STABLE_COUNT); speedLowCount = 0;
  } else if(currentSpeed < SPEED_DOWN_THRESHOLD) {
    speedLowCount = min(speedLowCount + 1, SPEED_STABLE_COUNT); speedHighCount = 0;
  }

  // 4. 感測器讀取
  readIMU();
  readMotorCurrent();
  emergencyStopPressed = (digitalRead(EMERGENCY_STOP_PIN) == (BUTTON_IS_NC_TYPE ? HIGH : LOW));

  // 5. 紅外線
  if(IrReceiver.decode()) { handleIRCommand(IrReceiver.decodedIRData.decodedRawData); IrReceiver.resume(); }

  // 6. 邏輯執行
  decidePriority();
  executeByPriority();
  handleStateMachine();
  
  // 7. 顯示與監控
  if(millis() - lastDisplayTime > 250) { lastDisplayTime = millis(); drawDashboard(); }
  
  if(millis() - lastPrintTime > 500) {
    lastPrintTime = millis();
    Serial.print(F("速度:")); Serial.print(currentSpeed, 1);
    Serial.print(F(" PWM:")); Serial.print(pwmSpeedUp);
    Serial.print(F(" 狀態:")); Serial.println(currentState);
  }
  
  delay(2);
}
