// ===== 腳位 =====
const int PWM_PIN = 9;
const byte LIMIT_UP_PIN = 52;        // 上限位開關
const byte LIMIT_DOWN_PIN = 53;      // 下限位開關

// ===== 參數 =====
const float SPEED_START = 15.0;   // km/h
const int PWM_SPEED = 180;
const unsigned long MAX_RUN_TIME = 30000; // 30秒安全保護

// ===== 狀態 =====
enum State { STOPPED, RUNNING };
State state = STOPPED;
float currentSpeed = 0.0;
unsigned long runStartTime = 0;

// ===== 模擬速度 =====
float getSpeedKmH() {
  static float s = 0;
  static unsigned long t = 0;
  if (millis() - t > 1000) {
    t = millis();
    s += 1;
    if (s > 20) s = 0;
  }
  return s;
}

// ===== 限位開關防彈跳讀取 =====
bool readLimitSwitch(int pin) {
  if (digitalRead(pin) == LOW) {
    delay(5);  // 5ms 防彈跳
    return (digitalRead(pin) == LOW);
  }
  return false;
}

// ===== 馬達控制 =====
void motorStart() {
  analogWrite(PWM_PIN, PWM_SPEED);
  runStartTime = millis();
  Serial.println("致動器:啟動");
}

void motorStop() {
  analogWrite(PWM_PIN, 0);
  Serial.println("致動器:停止");
}

void setup() {
  Serial.begin(115200);
  pinMode(PWM_PIN, OUTPUT);
  pinMode(UPPER_LIMIT_PIN, INPUT_PULLUP);
  pinMode(LOWER_LIMIT_PIN, INPUT_PULLUP);
  motorStop();
  Serial.println("=== 單方向線性致動器測試 ===");
}

void loop() {
  static unsigned long lastPrint = 0;
  
  currentSpeed = getSpeedKmH();
  bool upperHit = readLimitSwitch(UPPER_LIMIT_PIN);
  bool lowerHit = readLimitSwitch(LOWER_LIMIT_PIN);
  
  // ===== 狀態顯示 =====
  if (millis() - lastPrint > 1000) {
    lastPrint = millis();
    Serial.print("速度=");
    Serial.print(currentSpeed, 1);
    Serial.print(" km/h | 上限=");
    Serial.print(upperHit ? "觸發" : "---");
    Serial.print(" | 下限=");
    Serial.print(lowerHit ? "觸發" : "---");
    Serial.print(" | 狀態=");
    Serial.println(state == RUNNING ? "RUNNING" : "STOPPED");
  }
  
  // ===== 控制邏輯 =====
  if (state == STOPPED) {
    // 啟動條件:
    // 1. 速度達標
    // 2. 未碰到上限(避免逆推)
    if (currentSpeed >= SPEED_START && !upperHit) {
      motorStart();
      state = RUNNING;
    }
  }
  
  if (state == RUNNING) {
    // 停止條件:
    // 1. 碰到上限
    // 2. 碰到下限(異常情況)
    // 3. 速度降低
    // 4. 運行時間過長(安全保護)
    if (upperHit || lowerHit || 
        currentSpeed < SPEED_START ||
        (millis() - runStartTime > MAX_RUN_TIME)) {
      
      if (millis() - runStartTime > MAX_RUN_TIME) {
        Serial.println("⚠️ 安全逾時保護觸發!");
      }
      
      motorStop();
      state = STOPPED;
    }
  }
  
  delay(10);
}
