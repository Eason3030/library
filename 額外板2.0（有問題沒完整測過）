// ============================================================================
// 自行車輔助輪智能控制系統 v3.7 (救援版)
// 基於 v3.3 修改
//
// ★ 修改重點：
// 1. 按鈕邏輯改為 FALSE (適配一般常開按鈕)
// 2. 預設關閉電流保護 (排除電流誤判導致重置)
// ============================================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <INA226_WE.h>

// ★★★★★ 設定區 (如果還是一直重置，請看這裡) ★★★★★

// 1. 按鈕邏輯設定
// 上一版設為 true 導致一直重置，所以這版我們改為 false。
// false = 正常按鈕 (平常斷開，按下去才導通)
// true  = 工業急停 (平常導通，按下去才斷開)
const bool BUTTON_IS_NC_TYPE = false;

// 2. 電流保護開關
// 先設為 true (忽略電流)，確保不是因為電流感測器亂跳導致重置
const bool IGNORE_CURRENT_SENSOR = true;

// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

// ============================================================================
// 音符與硬體定義
// ============================================================================
#define NOTE_C5  523
#define NOTE_E5  659
#define NOTE_G5  784
#define NOTE_C6  1047
#define NOTE_A5  880

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define MPU_6050 0x68
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B
#define GYRO_XOUT_H  0x43

const byte BUZZER_PIN = 8;
const byte RELAY_PIN = 11;
const byte IR_RECEIVE_PIN = 3;
const byte HALL_STOP_UP_PIN = 4;
const byte HALL_STOP_DOWN_PIN = 10;
const byte HALL_SPEED_PIN = 2;
const byte EMERGENCY_STOP_PIN = 12; // 您的急停按鈕
const byte PWM_CONTROL_PIN = 9;
const byte SPEED_POT_PIN = A0;

const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;
const bool RGB_COMMON_ANODE = false;

enum RGBColor : byte { RGB_OFF = 0, RGB_GREEN, RGB_YELLOW, RGB_BLUE, RGB_RED, RGB_PURPLE };

INA226_WE ina226;
const float MAX_CURRENT_A = 5.0;
const float BUZZER_CURRENT_THRESHOLD = 1.5;
float current_A = 0.0;

const uint16_t PWM_ON_DURATION = 1800;
const uint16_t PWM_OFF_DURATION = 1800;
uint32_t pwmPreviousMillis = 0;
bool pwmState = false;

#define WHEEL_CIRCUMFERENCE 204.2
const float SPEED_THRESHOLD = 10.0;
const uint16_t SPEED_TIMEOUT = 2000;
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t timeBetweenTriggers = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
uint32_t lastSpeedUpdate = 0;

float compAngleX = 0.0f;
float gyroBiasX = 0.0f;
float accelBiasX = 0.0f;

const float SAFE_ANGLE = 20.0f;
const float TILT_SAFE = 12.0f;
const float EMERGENCY_ANGLE = 35.0f;
const uint16_t TILT_TRIGGER_TIME = 500;
const uint16_t AUTO_UP_DELAY = 3000;

uint32_t tiltStartTime = 0;
bool tiltWarning = false;
uint32_t safeStartTime = 0;

enum SystemState : byte { RUNNING, COOLING_DOWN };
SystemState currentSystemState = RUNNING;
uint32_t haltTime = 0;
const uint16_t RESTART_DELAY_MS = 5000; // 鎖定 5 秒

bool hallStopLocked = false;
byte lastHallStopUpState = HIGH;
byte lastHallStopDownState = HIGH;
bool wheelDown = false;
bool relayCmd = LOW;
byte ctrlSrc = 0;
bool manualMode = false;

uint32_t wheelAnimStartTime = 0;
bool showWheelAnim = false;
uint32_t lastPrintTime = 0;
uint32_t lastDisplayTime = 0;
uint32_t lastIRCode = 0;
const uint16_t IR_DELAY = 500;

// 輔助函式
void setRGB(byte r, byte g, byte b) { if (RGB_COMMON_ANODE) { analogWrite(RGB_RED_PIN, 255 - r); analogWrite(RGB_GREEN_PIN, 255 - g); analogWrite(RGB_BLUE_PIN, 255 - b); } else { analogWrite(RGB_RED_PIN, r); analogWrite(RGB_GREEN_PIN, g); analogWrite(RGB_BLUE_PIN, b); } }
void setRGBColor(RGBColor c) { switch (c) { case RGB_OFF: setRGB(0, 0, 0); break; case RGB_GREEN: setRGB(0, 255, 0); break; case RGB_YELLOW: setRGB(255, 255, 0); break; case RGB_BLUE: setRGB(0, 0, 255); break; case RGB_RED: setRGB(255, 0, 0); break; case RGB_PURPLE: setRGB(128, 0, 255); break; } }
void beep(uint16_t freq, byte duration) { tone(BUZZER_PIN, freq, duration); delay(duration); noTone(BUZZER_PIN); }
void soundStartup() { beep(NOTE_C5, 100); beep(NOTE_G5, 150); beep(NOTE_C6, 200); }
void soundDown() { beep(NOTE_G5, 60); beep(NOTE_C5, 100); }
void soundUp() { beep(NOTE_C5, 60); beep(NOTE_G5, 100); }
void soundLock() { beep(NOTE_C6, 80); beep(NOTE_E5, 80); }
void soundEmergency() { for (byte i = 0; i < 3; i++) { beep(NOTE_C6, 100); delay(50); beep(NOTE_A5, 100); delay(50); } }
void speedInterrupt() { uint32_t t = micros(); if (t - lastSpeedTrigger > 50000) { timeBetweenTriggers = t - lastSpeedTrigger; lastSpeedTrigger = t; newSpeedData = true; } }
float calculateSpeed() { if (timeBetweenTriggers == 0) return 0.0; float timeInSec = timeBetweenTriggers / 1000000.0; return (WHEEL_CIRCUMFERENCE / timeInSec) * 0.036; }
int16_t read16(byte reg) { Wire.beginTransmission(MPU_6050); Wire.write(reg); Wire.endTransmission(false); Wire.requestFrom((byte)MPU_6050, (byte)2); return (Wire.read() << 8) | Wire.read(); }
void setupMPU() { Wire.beginTransmission(MPU_6050); Wire.write(PWR_MGMT_1); Wire.write(0x00); Wire.endTransmission(); delay(50); }
void calibrateIMU() { float sumAx = 0, sumGx = 0; for (byte i = 0; i < 50; i++) { sumAx += read16(ACCEL_XOUT_H) / 16384.0f; sumGx += read16(GYRO_XOUT_H) / 131.0f; delay(5); } accelBiasX = sumAx / 50; gyroBiasX = sumGx / 50; }
void readIMU(float &ax, float &gx) { ax = read16(ACCEL_XOUT_H) / 16384.0f; float az = read16(ACCEL_XOUT_H + 4) / 16384.0f; gx = read16(GYRO_XOUT_H) / 131.0f; gx -= gyroBiasX; ax -= accelBiasX; float accelAngle = atan2(ax, az) * 57.2958f; compAngleX = 0.98 * (compAngleX + gx * 0.01) + 0.02 * accelAngle; }
void showStartup() { display.clearDisplay(); display.setTextSize(2); display.setTextColor(SSD1306_WHITE); display.setCursor(10, 10); display.print(F("Fixing...")); display.display(); delay(500); }
void showStatus() {
  display.clearDisplay(); display.drawRect(0, 0, 128, 32, SSD1306_WHITE); display.setTextSize(1); display.setCursor(4, 3);
  if (currentSystemState == COOLING_DOWN) { display.print(F("LOCKED 5s")); }
  else { display.print(F("RUN")); }
  display.print(F(" ")); display.print((int)currentSpeed); display.print(F("k ")); display.print((int)compAngleX); display.print(F("d"));
  if (currentSystemState == COOLING_DOWN) { display.setCursor(114, 3); display.print(F("!!")); }
  display.setTextSize(2); display.setCursor(12, 15);
  if (currentSystemState == COOLING_DOWN) display.print(F("STOPPED"));
  else display.print(wheelDown ? F("DOWN") : F("UP"));
  display.display();
}
void handleIRCommand(uint32_t code) { if (millis() - lastIRCode > IR_DELAY) { lastIRCode = millis(); if (hallStopLocked) hallStopLocked = false; wheelDown = !wheelDown; manualMode = true; ctrlSrc = 2; beep(NOTE_A5, 40); showWheelAnim = true; wheelAnimStartTime = millis(); } }

void setup() {
  Serial.begin(115200); delay(100); Wire.begin();
 
  pinMode(BUZZER_PIN, OUTPUT); pinMode(RELAY_PIN, OUTPUT);
  pinMode(HALL_STOP_UP_PIN, INPUT_PULLUP); pinMode(HALL_STOP_DOWN_PIN, INPUT_PULLUP); pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
 
  // 關鍵：使用 INPUT_PULLUP
  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);
 
  pinMode(PWM_CONTROL_PIN, OUTPUT);
  pinMode(RGB_RED_PIN, OUTPUT); pinMode(RGB_GREEN_PIN, OUTPUT); pinMode(RGB_BLUE_PIN, OUTPUT);
 
  digitalWrite(RELAY_PIN, LOW); analogWrite(PWM_CONTROL_PIN, 0); setRGBColor(RGB_OFF);
 
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
 
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { while (1); }
 
  ina226.init();
  setupMPU(); calibrateIMU();
  showStartup(); soundStartup();
}

void loop() {
  uint32_t currentMillis = millis();

  // 1. 讀值
  float ax, gx; readIMU(ax, gx);
  current_A = ina226.getCurrent_A();
  if (newSpeedData) { currentSpeed = calculateSpeed(); newSpeedData = false; lastSpeedUpdate = millis(); }
  if (millis() - lastSpeedUpdate > SPEED_TIMEOUT) { currentSpeed = 0.0; }
  if (IrReceiver.decode()) { handleIRCommand(IrReceiver.decodedIRData.decodedRawData); IrReceiver.resume(); }

  byte hallStopUp = digitalRead(HALL_STOP_UP_PIN);
  byte hallStopDown = digitalRead(HALL_STOP_DOWN_PIN);
  if (hallStopUp != lastHallStopUpState) { lastHallStopUpState = hallStopUp; if (hallStopUp == LOW) { hallStopLocked = true; manualMode = false; wheelDown = false; ctrlSrc = 1; soundLock(); } }
  if (hallStopDown != lastHallStopDownState) { lastHallStopDownState = hallStopDown; if (hallStopDown == LOW) { hallStopLocked = true; manualMode = false; wheelDown = true; ctrlSrc = 1; soundLock(); } }

  // ========================================================================
  // 核心：修正後的觸發邏輯
  // ========================================================================
 
  int btnReading = digitalRead(EMERGENCY_STOP_PIN);
  bool isButtonPressed = false;

  // 根據上方設定決定邏輯
  if (BUTTON_IS_NC_TYPE) {
      // NC模式 (上一版是用這個): 讀到 HIGH (斷路) = 按下
      isButtonPressed = (btnReading == HIGH);
  } else {
      // NO模式 (這一版改成這個): 讀到 LOW (接地) = 按下
      isButtonPressed = (btnReading == LOW);
  }

  // 電流保護
  bool isOverloaded = false;
  if (!IGNORE_CURRENT_SENSOR) {
      isOverloaded = (current_A > MAX_CURRENT_A);
  }

  bool haltTrigger = isOverloaded || isButtonPressed;

  // 開機 3 秒防護 (避免開機瞬間錯誤)
  if (millis() < 3000) haltTrigger = false;

  // ========================================================================
  // 狀態機
  // ========================================================================
 
  bool allowRun = true;
  RGBColor targetRGB = RGB_GREEN;
  relayCmd = LOW;

  switch (currentSystemState) {
    case RUNNING:
      if (haltTrigger) {
        currentSystemState = COOLING_DOWN;
        haltTime = currentMillis;
        soundEmergency();
       
        // 序列埠除錯：告訴你是什麼觸發了停止
        Serial.print(F("STOPPED BY: "));
        if (isButtonPressed) Serial.print(F("BUTTON "));
        if (isOverloaded) Serial.print(F("CURRENT "));
        Serial.println();

        analogWrite(PWM_CONTROL_PIN, 0);
        digitalWrite(RELAY_PIN, LOW);
        pwmState = false;
      }
      break;
     
    case COOLING_DOWN:
      allowRun = false;
      relayCmd = LOW;
      analogWrite(PWM_CONTROL_PIN, 0);
      targetRGB = RGB_RED;

      if (currentMillis - haltTime >= RESTART_DELAY_MS) {
          currentSystemState = RUNNING;
          manualMode = false;
          hallStopLocked = false;
          Serial.println(F("RECOVERED"));
          soundUp();
      }
      break;
  }

  if (allowRun) {
      // 傾斜保護
      if (abs(compAngleX) > EMERGENCY_ANGLE) {
         currentSystemState = COOLING_DOWN; haltTime = currentMillis; soundEmergency(); allowRun = false;
      } else if (abs(compAngleX) > SAFE_ANGLE) {
         if (tiltStartTime == 0) tiltStartTime = millis();
         if (!tiltWarning && (millis() - tiltStartTime >= TILT_TRIGGER_TIME)) {
             tiltWarning = true; wheelDown = true; manualMode = false; beep(NOTE_G5, 150); soundDown(); safeStartTime = 0;
         }
      } else {
         tiltStartTime = 0;
         if (tiltWarning) {
            if (abs(compAngleX) < TILT_SAFE) {
               if (safeStartTime == 0) safeStartTime = millis();
               if (millis() - safeStartTime >= AUTO_UP_DELAY) { tiltWarning = false; wheelDown = false; manualMode = false; soundUp(); safeStartTime = 0; }
            } else safeStartTime = 0;
         }
      }
      if (tiltWarning) { relayCmd = HIGH; wheelDown = true; targetRGB = RGB_BLUE; allowRun = false; }
  }

  if (allowRun) {
      if (hallStopLocked || manualMode) {
          relayCmd = wheelDown ? HIGH : LOW; targetRGB = wheelDown ? RGB_YELLOW : RGB_GREEN;
      } else {
          wheelDown = (currentSpeed < SPEED_THRESHOLD);
          relayCmd = wheelDown ? HIGH : LOW;
          targetRGB = wheelDown ? RGB_YELLOW : RGB_GREEN;
          if (wheelDown != (currentSpeed < SPEED_THRESHOLD)) { if (wheelDown) soundDown(); else soundUp(); }
      }

      if (relayCmd == HIGH && !hallStopLocked) {
         if (currentMillis - pwmPreviousMillis >= (pwmState ? PWM_ON_DURATION : PWM_OFF_DURATION)) {
             pwmPreviousMillis = currentMillis; pwmState = !pwmState;
             analogWrite(PWM_CONTROL_PIN, pwmState ? map(analogRead(SPEED_POT_PIN),0,1023,0,255) : 0);
         }
      } else {
         analogWrite(PWM_CONTROL_PIN, 0);
      }
  }

  digitalWrite(RELAY_PIN, relayCmd);
  setRGBColor(targetRGB);

  if (millis() - lastDisplayTime > 50) { showStatus(); lastDisplayTime = millis(); }
}