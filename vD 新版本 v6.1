// ============================================================================
// 雙致動器智能控制系統 v7.0 - 完整修正版
// 主要改進:
// 1. 修正限位開關檢測邏輯 (移除不支援的中斷腳位)
// 2. 完整音效系統 (5種獨立音效)
// 3. 單致動器測試模式 (只啟用左側 Pin 52/53)
// 4. 優化 OLED 介面顯示
// 5. 修正速度閾值為 15 km/h
// 6. 簡化同步邏輯
// ============================================================================

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <IRremote.h>
#include <INA226_WE.h>
#include <avr/wdt.h>

// ============================================================================
// OLED 螢幕設定
// ============================================================================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ============================================================================
// 系統設定
// ============================================================================
const bool BUTTON_IS_NC_TYPE = true;
const bool IGNORE_CURRENT_SENSOR = true;  // 暫時停用電流檢測
const bool SINGLE_ACTUATOR_TEST = true;   // 單致動器測試模式

// ============================================================================
// 音符定義 - 完整音效系統
// ============================================================================
#define NOTE_C4  262
#define NOTE_E4  330
#define NOTE_G4  392
#define NOTE_C5  523
#define NOTE_E5  659
#define NOTE_G5  784
#define NOTE_A5  880
#define NOTE_C6  1047

// ============================================================================
// MPU6050 設定
// ============================================================================
#define MPU_6050 0x69
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B
#define GYRO_XOUT_H  0x43

// ============================================================================
// 腳位定義
// ============================================================================
const byte BUZZER_PIN = 8;
const byte IR_RECEIVE_PIN = 3;
const byte PWM_PIN = 9;

// 致動器 1 (左側) 限位開關 - 測試中
const byte LIMIT_LEFT_UP_PIN = 52;
const byte LIMIT_LEFT_DOWN_PIN = 53;

// 致動器 2 (右側) 限位開關 - 暫時保留
const byte LIMIT_RIGHT_UP_PIN = 13;
const byte LIMIT_RIGHT_DOWN_PIN = A1;

// 共用控制
const byte HALL_SPEED_PIN = 2;
const byte EMERGENCY_STOP_PIN = 12;
const byte RESET_BUTTON_PIN = A2;
const byte SPEED_CONTROL_PIN = A0;

// RGB LED
const byte RGB_RED_PIN = 5;
const byte RGB_GREEN_PIN = 7;
const byte RGB_BLUE_PIN = 6;
const bool RGB_COMMON_ANODE = false;

// ============================================================================
// 狀態定義
// ============================================================================
enum SystemState : byte {
  STATE_INIT,
  STATE_STANDBY,
  STATE_RISING,
  STATE_UP,
  STATE_FALLING,
  STATE_EMERGENCY_STOP,
  STATE_OVERCURRENT,
  STATE_COOLING
};

enum ControlPriority : byte {
  PRIORITY_EMERGENCY = 0,
  PRIORITY_SAFETY_DOWN = 1,
  PRIORITY_COOLING = 2,
  PRIORITY_MANUAL = 3,
  PRIORITY_AUTO = 4
};

enum RGBColor : byte {
  RGB_OFF,
  RGB_GREEN,
  RGB_YELLOW,
  RGB_BLUE,
  RGB_RED,
  RGB_PURPLE,
  RGB_CYAN,
  RGB_WHITE
};

// ============================================================================
// 音效類型定義
// ============================================================================
enum SoundEffect : byte {
  SOUND_NONE,
  SOUND_INIT_COMPLETE,    // 初始化完成
  SOUND_RISING,           // 開始上升
  SOUND_FALLING,          // 開始下降
  SOUND_BUTTON,           // 按鈕/IR
  SOUND_TILT_WARNING,     // 傾斜警告
  SOUND_LIMIT_REACHED,    // 到達限位
  SOUND_EMERGENCY         // 緊急停止
};

// ============================================================================
// 致動器狀態結構
// ============================================================================
struct ActuatorStatus {
  bool upLimitPressed;
  bool downLimitPressed;
  bool upLimitPrevious;      // 前一次狀態
  bool downLimitPrevious;    // 前一次狀態
  uint32_t lastChangeTime;
  uint16_t debounceTime;
  bool isActive;             // 是否啟用此致動器
};

ActuatorStatus actuator1 = {false, false, false, false, 0, 50, true};   // 左側 - 測試中
ActuatorStatus actuator2 = {false, false, false, false, 0, 50, false};  // 右側 - 暫停

// ============================================================================
// 全域變數
// ============================================================================
INA226_WE ina226;
const float MAX_CURRENT_A = 3.0;
float current_A = 0.0;

SystemState currentState = STATE_INIT;
SystemState previousState = STATE_INIT;
ControlPriority currentPriority = PRIORITY_AUTO;

// 同步控制
bool bothAtBottom = false;
bool bothAtTop = false;
bool anyAtTop = false;
bool anyAtBottom = false;
unsigned long syncTimeout = 0;
const unsigned long SYNC_TIMEOUT_MS = 10000;  // 10秒超時保護

// PWM 控制
int pwmSpeedUp = 200;
int pwmSpeedDown = 180;
unsigned long lastSpeedRead = 0;

// 速度測量
#define WHEEL_CIRCUMFERENCE 204.2
const uint16_t SPEED_TIMEOUT = 2000;
volatile uint32_t lastSpeedTrigger = 0;
volatile uint32_t timeBetweenTriggers = 0;
volatile bool newSpeedData = false;
float currentSpeed = 0.0;
uint32_t lastSpeedUpdate = 0;

// IMU 資料
float compAngleX = 0.0f;
float gyroBiasX = 0.0f;
float accelBiasX = 0.0f;
uint32_t lastIMUTime = 0;
bool i2cHealthy = true;
uint32_t lastI2CSuccess = 0;
const uint16_t I2C_TIMEOUT = 5000;

// 安全閾值
const float SAFE_ANGLE = 10.0f;
const float TILT_SAFE = 5.0f;
const float EMERGENCY_ANGLE = 15.0f;
const uint16_t TILT_TRIGGER_TIME = 500;
const uint16_t AUTO_UP_DELAY = 3000;
uint32_t tiltStartTime = 0;
bool tiltWarning = false;
uint32_t safeStartTime = 0;

// 速度控制 - 修正為 15 km/h
const byte SPEED_STABLE_COUNT = 3;
byte speedLowCount = 0;
byte speedHighCount = 0;
const float SPEED_UP_THRESHOLD = 15.0;      // 修正: 15 km/h 上升
const float SPEED_DOWN_THRESHOLD = 10.0;    // 10 km/h 下降
const float SPEED_MIN_SAFE = 5.0;

// 控制變數
bool wheelDown = true;
bool manualMode = false;
byte ctrlSrc = 0;

// 緊急停止
bool emergencyStopPressed = false;
bool manualResetConfirmed = false;
uint32_t haltTime = 0;
bool overCurrentDetected = false;
bool irCommandReceived = false;

// 時間控制
uint32_t lastPrintTime = 0;
uint32_t lastDisplayTime = 0;
uint32_t lastIRCode = 0;
const uint16_t IR_DELAY = 500;

// 非阻塞音效 - 增強版
struct BeepQueue {
  uint16_t frequency;
  uint16_t duration;
  uint16_t pause;
  bool active;
};

BeepQueue beepQueue[3];
byte beepIndex = 0;
uint32_t beepEndTime = 0;
bool isBeeping = false;

// 看門狗
uint32_t lastLoopTime = 0;
const uint32_t WATCHDOG_TIMEOUT = 2000;

// OLED 動畫
byte animFrame = 0;
uint32_t lastAnimTime = 0;

// ============================================================================
// 中斷服務程序
// ============================================================================
void speedInterrupt() {
  uint32_t t = micros();
  if (t - lastSpeedTrigger > 40000) {
    timeBetweenTriggers = t - lastSpeedTrigger;
    lastSpeedTrigger = t;
    newSpeedData = true;
  }
}

// ============================================================================
// RGB LED 控制
// ============================================================================
void setRGB(byte r, byte g, byte b) {
  if (RGB_COMMON_ANODE) {
    analogWrite(RGB_RED_PIN, 255-r);
    analogWrite(RGB_GREEN_PIN, 255-g);
    analogWrite(RGB_BLUE_PIN, 255-b);
  } else {
    analogWrite(RGB_RED_PIN, r);
    analogWrite(RGB_GREEN_PIN, g);
    analogWrite(RGB_BLUE_PIN, b);
  }
}

void setRGBColor(RGBColor c) {
  switch(c) {
    case RGB_OFF: setRGB(0,0,0); break;
    case RGB_GREEN: setRGB(0,255,0); break;
    case RGB_YELLOW: setRGB(255,200,0); break;
    case RGB_BLUE: setRGB(0,100,255); break;
    case RGB_RED: setRGB(255,0,0); break;
    case RGB_PURPLE: setRGB(180,0,255); break;
    case RGB_CYAN: setRGB(0,255,255); break;
    case RGB_WHITE: setRGB(255,255,255); break;
  }
}

RGBColor decideRGB() {
  switch(currentPriority) {
    case PRIORITY_EMERGENCY:
    case PRIORITY_COOLING:
      return RGB_RED;
    case PRIORITY_SAFETY_DOWN:
      return RGB_BLUE;
    case PRIORITY_MANUAL:
      return RGB_PURPLE;
    default:
      if (currentState == STATE_RISING) return RGB_GREEN;
      if (currentState == STATE_FALLING) return RGB_YELLOW;
      if (currentState == STATE_UP) return RGB_CYAN;
      return wheelDown ? RGB_YELLOW : RGB_GREEN;
  }
}

// ============================================================================
// 增強型音效系統
// ============================================================================
void playSound(SoundEffect sound) {
  // 清空佇列
  for(byte i = 0; i < 3; i++) {
    beepQueue[i].active = false;
  }
  beepIndex = 0;
  
  switch(sound) {
    case SOUND_INIT_COMPLETE:
      beepQueue[0] = {NOTE_C5, 100, 50, true};
      beepQueue[1] = {NOTE_E5, 100, 50, true};
      beepQueue[2] = {NOTE_G5, 150, 0, true};
      break;
      
    case SOUND_RISING:
      beepQueue[0] = {NOTE_E5, 80, 30, true};
      beepQueue[1] = {NOTE_G5, 80, 30, true};
      beepQueue[2] = {NOTE_C6, 120, 0, true};
      break;
      
    case SOUND_FALLING:
      beepQueue[0] = {NOTE_G5, 80, 30, true};
      beepQueue[1] = {NOTE_E5, 80, 30, true};
      beepQueue[2] = {NOTE_C5, 120, 0, true};
      break;
      
    case SOUND_BUTTON:
      beepQueue[0] = {NOTE_A5, 50, 0, true};
      break;
      
    case SOUND_TILT_WARNING:
      beepQueue[0] = {NOTE_C6, 100, 50, true};
      beepQueue[1] = {NOTE_C6, 100, 50, true};
      beepQueue[2] = {NOTE_C6, 100, 0, true};
      break;
      
    case SOUND_LIMIT_REACHED:
      beepQueue[0] = {NOTE_G5, 100, 0, true};
      break;
      
    case SOUND_EMERGENCY:
      beepQueue[0] = {NOTE_C6, 200, 100, true};
      beepQueue[1] = {NOTE_C6, 200, 0, true};
      break;
      
    default:
      return;
  }
  
  // 開始播放第一個音符
  if(beepQueue[0].active) {
    tone(BUZZER_PIN, beepQueue[0].frequency);
    beepEndTime = millis() + beepQueue[0].duration;
    isBeeping = true;
  }
}

void beepUpdate() {
  if(!isBeeping) return;
  
  if(millis() >= beepEndTime) {
    noTone(BUZZER_PIN);
    isBeeping = false;
    
    // 播放下一個音符
    if(beepQueue[beepIndex].pause > 0) {
      beepEndTime = millis() + beepQueue[beepIndex].pause;
      beepIndex++;
    } else {
      beepIndex++;
    }
    
    if(beepIndex < 3 && beepQueue[beepIndex].active) {
      delay(beepQueue[beepIndex-1].pause);
      tone(BUZZER_PIN, beepQueue[beepIndex].frequency);
      beepEndTime = millis() + beepQueue[beepIndex].duration;
      isBeeping = true;
    }
  }
}

// ============================================================================
// 速度計算
// ============================================================================
float calculateSpeed() {
  if (timeBetweenTriggers == 0) return 0.0;
  float timeInSec = timeBetweenTriggers/1000000.0;
  return (WHEEL_CIRCUMFERENCE/timeInSec)*0.036;
}

// ============================================================================
// MPU6050 函式
// ============================================================================
int16_t safeRead16(byte reg) {
  Wire.beginTransmission(MPU_6050);
  Wire.write(reg);
  byte error = Wire.endTransmission(false);

  if(error != 0) {
    i2cHealthy = false;
    return 0;
  }

  Wire.requestFrom((byte)MPU_6050, (byte)2);
  uint32_t start = millis();
  while (Wire.available() < 2) {
    if (millis() - start > 10) {
      i2cHealthy = false;
      return 0;
    }
  }

  i2cHealthy = true;
  lastI2CSuccess = millis();
  return (Wire.read()<<8)|Wire.read();
}

void setupMPU() {
  Wire.beginTransmission(MPU_6050);
  Wire.write(PWR_MGMT_1);
  Wire.write(0x00);
  Wire.endTransmission();
  delay(50);
}

void calibrateIMU() {
  Serial.println(F("校準 IMU..."));
  float sumAx=0, sumGx=0;
  for(byte i=0; i<50; i++) {
    sumAx += safeRead16(ACCEL_XOUT_H)/16384.0f;
    sumGx += safeRead16(GYRO_XOUT_H)/131.0f;
    delay(5);
  }
  accelBiasX = sumAx/50;
  gyroBiasX = sumGx/50;
  Serial.println(F("IMU 校準完成"));
}

void readIMU() {
  if(!i2cHealthy) return;

  uint32_t now = micros();
  float dt = (now - lastIMUTime) / 1000000.0;
  lastIMUTime = now;
  if (dt > 0.1) dt = 0.01;

  float ax = safeRead16(ACCEL_XOUT_H) / 16384.0f - accelBiasX;
  float az = safeRead16(ACCEL_XOUT_H + 4) / 16384.0f;
  float gx = safeRead16(GYRO_XOUT_H) / 131.0f - gyroBiasX;

  if(isnan(ax) || isnan(az) || isnan(gx) ||
     abs(ax) > 10 || abs(az) > 10 || abs(gx) > 500) {
    i2cHealthy = false;
    return;
  }

  float accelAngle = atan2(ax, az) * 57.2958f;
  compAngleX = 0.98 * (compAngleX + gx * dt) + 0.02 * accelAngle;

  if(compAngleX > 180) compAngleX = 180;
  if(compAngleX < -180) compAngleX = -180;
}

// ============================================================================
// 限位開關處理 - 輪詢模式 (移除中斷)
// ============================================================================
bool readLimitSwitch(byte pin, ActuatorStatus &actuator, bool isUp) {
  if(!actuator.isActive) return false;
  
  bool reading = (digitalRead(pin) == LOW);
  bool &current = isUp ? actuator.upLimitPressed : actuator.downLimitPressed;
  bool &previous = isUp ? actuator.upLimitPrevious : actuator.downLimitPrevious;
  
  if (reading != previous) {
    actuator.lastChangeTime = millis();
    previous = reading;
  }
  
  if((millis() - actuator.lastChangeTime > actuator.debounceTime)) {
    // 邊緣檢測: 從未觸發到觸發
    if(reading && !current) {
      current = true;
      return true;  // 新觸發
    }
    current = reading;
  }
  
  return false;
}

void updateLimitSwitches() {
  // 左側致動器 (測試中)
  bool leftUpTriggered = readLimitSwitch(LIMIT_LEFT_UP_PIN, actuator1, true);
  bool leftDownTriggered = readLimitSwitch(LIMIT_LEFT_DOWN_PIN, actuator1, false);
  
  // 右側致動器 (暫停)
  if(!SINGLE_ACTUATOR_TEST) {
    readLimitSwitch(LIMIT_RIGHT_UP_PIN, actuator2, true);
    readLimitSwitch(LIMIT_RIGHT_DOWN_PIN, actuator2, false);
  }
  
  // 單致動器測試模式
  if(SINGLE_ACTUATOR_TEST) {
    bothAtBottom = actuator1.downLimitPressed;
    bothAtTop = actuator1.upLimitPressed;
    anyAtTop = actuator1.upLimitPressed;
    anyAtBottom = actuator1.downLimitPressed;
  } else {
    bothAtBottom = actuator1.downLimitPressed && actuator2.downLimitPressed;
    bothAtTop = actuator1.upLimitPressed && actuator2.upLimitPressed;
    anyAtTop = actuator1.upLimitPressed || actuator2.upLimitPressed;
    anyAtBottom = actuator1.downLimitPressed || actuator2.downLimitPressed;
  }
  
  // 觸發音效
  if(leftUpTriggered || leftDownTriggered) {
    playSound(SOUND_LIMIT_REACHED);
  }
}

// ============================================================================
// 限位檢查與 PWM 控制
// ============================================================================
void checkHardwareLimits() {
  if (anyAtTop && currentState == STATE_RISING) {
    analogWrite(PWM_PIN, 0);
    Serial.println(F("[限位] 上限觸發 - 停止"));
  }
  
  if (anyAtBottom && (currentState == STATE_FALLING || currentState == STATE_INIT)) {
    analogWrite(PWM_PIN, 0);
    Serial.println(F("[限位] 下限觸發 - 停止"));
  }
}

void controlPWM(bool direction_up, int pwm_value) {
  if (direction_up && anyAtTop) {
    analogWrite(PWM_PIN, 0);
    return;
  }
  
  if (!direction_up && anyAtBottom) {
    analogWrite(PWM_PIN, 0);
    return;
  }
  
  analogWrite(PWM_PIN, pwm_value);
}

void stopAllPWM() {
  analogWrite(PWM_PIN, 0);
}

void moveUp() {
  controlPWM(true, pwmSpeedUp);
}

void moveDown() {
  controlPWM(false, pwmSpeedDown);
}

// ============================================================================
// A0 速度控制讀取
// ============================================================================
void readSpeedControl() {
  if (millis() - lastSpeedRead > 100) {
    lastSpeedRead = millis();
    int speedControlValue = analogRead(SPEED_CONTROL_PIN);
    pwmSpeedUp = map(speedControlValue, 0, 1023, 80, 255);
    pwmSpeedDown = map(speedControlValue, 0, 1023, 80, 220);
    pwmSpeedUp = constrain(pwmSpeedUp, 80, 255);
    pwmSpeedDown = constrain(pwmSpeedDown, 80, 220);
  }
}

// ============================================================================
// 電流讀取
// ============================================================================
void readMotorCurrent() {
  if(IGNORE_CURRENT_SENSOR) {
    current_A = 0.0;
  } else {
    float tempCurrent = ina226.getCurrent_A();
    if(isnan(tempCurrent) || tempCurrent < -1.0 || tempCurrent > 10.0) {
      current_A = 0.0;
    } else {
      current_A = abs(tempCurrent);
    }
  }
}

// ============================================================================
// 優先權決策
// ============================================================================
void decidePriority() {
  if (emergencyStopPressed ||
      (!IGNORE_CURRENT_SENSOR && current_A > MAX_CURRENT_A) ||
      (abs(compAngleX) > EMERGENCY_ANGLE)) {
    currentPriority = PRIORITY_EMERGENCY;
    return;
  }

  if (tiltWarning) {
    currentPriority = PRIORITY_SAFETY_DOWN;
    return;
  }
  
  if (!wheelDown && 
      currentSpeed < SPEED_DOWN_THRESHOLD && 
      speedLowCount >= SPEED_STABLE_COUNT) {
    currentPriority = PRIORITY_SAFETY_DOWN;
    return;
  }

  if (currentState == STATE_COOLING) {
    currentPriority = PRIORITY_COOLING;
    return;
  }

  if (manualMode) {
    currentPriority = PRIORITY_MANUAL;
    return;
  }

  currentPriority = PRIORITY_AUTO;
}

// ============================================================================
// 根據優先權執行動作
// ============================================================================
void executeByPriority() {
  switch(currentPriority) {
    
    case PRIORITY_EMERGENCY:
      wheelDown = true;
      manualMode = false;
      ctrlSrc = 0;
      
      if(currentState != STATE_COOLING && currentState != STATE_EMERGENCY_STOP) {
        previousState = currentState;
        currentState = STATE_EMERGENCY_STOP;
        haltTime = millis();
        playSound(SOUND_EMERGENCY);
        Serial.println(F("!!! 緊急停止觸發 !!!"));
      }
      break;
      
    case PRIORITY_SAFETY_DOWN:
      wheelDown = true;
      manualMode = false;
      ctrlSrc = 4;
      break;
      
    case PRIORITY_COOLING:
      wheelDown = true;
      manualMode = false;
      ctrlSrc = 0;
      break;
      
    case PRIORITY_MANUAL:
      ctrlSrc = 2;
      break;
      
    case PRIORITY_AUTO:
      if(currentSpeed >= SPEED_UP_THRESHOLD && speedHighCount >= SPEED_STABLE_COUNT) {
        if(wheelDown) {
          wheelDown = false;
          ctrlSrc = 3;
          Serial.println(F("自動: 上升 (速度 >= 15km/h)"));
        }
      } 
      else if(currentSpeed < SPEED_DOWN_THRESHOLD && speedLowCount >= SPEED_STABLE_COUNT) {
        if(!wheelDown) {
          wheelDown = true;
          ctrlSrc = 3;
          Serial.println(F("自動: 下降 (速度 < 10km/h)"));
        }
      }
      break;
  }
}

// ============================================================================
// 狀態機核心邏輯
// ============================================================================
void handleStateMachine() {
  checkHardwareLimits();
  
  switch (currentState) {
    
    case STATE_INIT:
      if (!bothAtBottom) {
        moveDown();
        
        if (syncTimeout == 0) {
          syncTimeout = millis();
          Serial.println(F("[INIT] 初始化: 下降至底部..."));
        }
        
        if (millis() - syncTimeout > SYNC_TIMEOUT_MS) {
          Serial.println(F("[INIT] 錯誤: 超時保護觸發!"));
          stopAllPWM();
          currentState = STATE_EMERGENCY_STOP;
        }
      } else {
        stopAllPWM();
        syncTimeout = 0;
        currentState = STATE_STANDBY;
        Serial.println(F("[INIT] 初始化完成 → 待機"));
        playSound(SOUND_INIT_COMPLETE);
      }
      break;
    
    case STATE_STANDBY:
      stopAllPWM();
      
      if (currentPriority == PRIORITY_EMERGENCY) {
        currentState = STATE_EMERGENCY_STOP;
        break;
      }
      
      if (!wheelDown && currentSpeed >= SPEED_UP_THRESHOLD && currentSpeed >= SPEED_MIN_SAFE) {
        currentState = STATE_RISING;
        syncTimeout = millis();
        Serial.println(F("[STANDBY] 待機 → 上升"));
        playSound(SOUND_RISING);
        break;
      }
      
      if (wheelDown && irCommandReceived) {
        Serial.println(F("[STANDBY] 已在底部"));
        irCommandReceived = false;
      }
      break;
    
    case STATE_RISING:
      if (currentPriority == PRIORITY_EMERGENCY) {
        stopAllPWM();
        currentState = STATE_EMERGENCY_STOP;
        break;
      }
      
      if (currentSpeed < SPEED_MIN_SAFE || wheelDown || irCommandReceived) {
        stopAllPWM();
        currentState = STATE_FALLING;
        syncTimeout = millis();
        Serial.println(F("[RISING] 上升 → 下降"));
        playSound(SOUND_FALLING);
        irCommandReceived = false;
        break;
      }
      
      if (bothAtTop) {
        stopAllPWM();
        syncTimeout = 0;
        currentState = STATE_UP;
        Serial.println(F("[RISING] 到達頂部"));
        playSound(SOUND_LIMIT_REACHED);
      } else {
        moveUp();
        
        if (millis() - syncTimeout > SYNC_TIMEOUT_MS) {
          Serial.println(F("[RISING] 錯誤: 超時保護!"));
          stopAllPWM();
          currentState = STATE_EMERGENCY_STOP;
        }
      }
      break;
    
    case STATE_UP:
      stopAllPWM();
      
      if (currentPriority == PRIORITY_EMERGENCY) {
        currentState = STATE_EMERGENCY_STOP;
        break;
      }
      
      if (currentSpeed < SPEED_MIN_SAFE || wheelDown || irCommandReceived) {
        currentState = STATE_FALLING;
        syncTimeout = millis();
        Serial.println(F("[UP] 頂部 → 下降"));
        playSound(SOUND_FALLING);
        irCommandReceived = false;
        break;
      }
      break;
    
    case STATE_FALLING:
      if (currentPriority == PRIORITY_EMERGENCY) {
        stopAllPWM();
        currentState = STATE_EMERGENCY_STOP;
        break;
      }
      
      if (bothAtBottom) {
        stopAllPWM();
        syncTimeout = 0;
        currentState = STATE_STANDBY;
        Serial.println(F("[FALLING] 到達底部"));
        playSound(SOUND_LIMIT_REACHED);
      } else {
        moveDown();
        
        if (syncTimeout == 0) {
          syncTimeout = millis();
        }
        if (millis() - syncTimeout > SYNC_TIMEOUT_MS) {
          Serial.println(F("[FALLING] 錯誤: 超時保護!"));
          stopAllPWM();
          currentState = STATE_EMERGENCY_STOP;
        }
      }
      break;
    
    case STATE_EMERGENCY_STOP:
      stopAllPWM();
      
      if (!emergencyStopPressed && current_A < MAX_CURRENT_A * 0.8 && abs(compAngleX) < SAFE_ANGLE) {
        if (digitalRead(RESET_BUTTON_PIN) == LOW) {
          delay(50);
          if (digitalRead(RESET_BUTTON_PIN) == LOW) {
            Serial.println(F("[EMERGENCY] 手動重置"));
            currentState = STATE_INIT;
            syncTimeout = 0;
            playSound(SOUND_BUTTON);
          }
        }
      }
      break;
    
    case STATE_OVERCURRENT:
      stopAllPWM();
      
      if (current_A < MAX_CURRENT_A * 0.8) {
        Serial.println(F("[OVERCURRENT] 電流恢復"));
        currentState = previousState;
        delay(500);
      }
      break;
      
    case STATE_COOLING:
      stopAllPWM();
      
      if (digitalRead(RESET_BUTTON_PIN) == LOW) {
        delay(50);
        if (digitalRead(RESET_BUTTON_PIN) == LOW) {
          manualResetConfirmed = true;
          currentState = STATE_INIT;
          Serial.println(F("[COOLING] 手動重置確認"));
          playSound(SOUND_INIT_COMPLETE);
        }
      }
      break;
  }
}

// ============================================================================
// 紅外線處理
// ============================================================================
void handleIRCommand(uint32_t code) {
  if(millis() - lastIRCode < IR_DELAY) return;
  lastIRCode = millis();

  if(currentPriority < PRIORITY_MANUAL) {
    Serial.println(F("IR: 被更高優先權阻擋"));
    playSound(SOUND_BUTTON);
    return;
  }

  wheelDown = !wheelDown;
  manualMode = true;
  ctrlSrc = 2;
  irCommandReceived = true;

  playSound(SOUND_BUTTON);
  Serial.print(F("IR: 目標 "));
  Serial.println(wheelDown ? F("下降") : F("上升"));
}

// ============================================================================
// 優化的 OLED 顯示介面
// ============================================================================
void showStartupPro() {
  display.clearDisplay();
  
  // 標題動畫
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(10, 5);
  display.print(F("Bike!!"));
  
  // 版本號
  display.setTextSize(1);
  display.setCursor(35, 25);
  display.print(F("System"));
  
  display.setTextSize(2);
  display.setCursor(30, 40);
  display.print(F("v7.0"));
  
  display.display();
  delay(1500);
  
  // 載入動畫
  for(int i = 0; i < 3; i++) {
    display.fillRect(20 + i*30, 58, 20, 4, SSD1306_WHITE);
    display.display();
    delay(200);
  }
}

void drawProgressBar(int x, int y, int w, int h, float value, float max_val) {
  // 外框
  display.drawRect(x, y, w, h, SSD1306_WHITE);
  
  // 內部填充
  int fillWidth = (int)((value / max_val) * (w - 2));
  if(fillWidth > 0) {
    display.fillRect(x + 1, y + 1, fillWidth, h - 2, SSD1306_WHITE);
  }
}

void drawStatusIcon(int x, int y, SystemState state) {
  switch(state) {
    case STATE_RISING:
      // 上升箭頭
      display.drawLine(x+3, y+7, x+3, y, SSD1306_WHITE);
      display.drawLine(x+3, y, x+1, y+2, SSD1306_WHITE);
      display.drawLine(x+3, y, x+5, y+2, SSD1306_WHITE);
      break;
      
    case STATE_FALLING:
      // 下降箭頭
      display.drawLine(x+3, y, x+3, y+7, SSD1306_WHITE);
      display.drawLine(x+3, y+7, x+1, y+5, SSD1306_WHITE);
      display.drawLine(x+3, y+7, x+5, y+5, SSD1306_WHITE);
      break;
      
    case STATE_STANDBY:
    case STATE_UP:
      // 暫停符號
      display.fillRect(x+1, y, 2, 8, SSD1306_WHITE);
      display.fillRect(x+4, y, 2, 8, SSD1306_WHITE);
      break;
      
    case STATE_EMERGENCY_STOP:
      // 警告三角形
      display.drawTriangle(x+3, y, x, y+7, x+6, y+7, SSD1306_WHITE);
      display.drawPixel(x+3, y+3, SSD1306_WHITE);
      display.drawPixel(x+3, y+4, SSD1306_WHITE);
      display.drawPixel(x+3, y+6, SSD1306_WHITE);
      break;
      
    default:
      display.fillCircle(x+3, y+4, 3, SSD1306_WHITE);
      break;
  }
}

void drawDashboard() {
  display.clearDisplay();
  
  // ========== 頂部狀態列 ==========
  display.setTextSize(1);
  display.setCursor(0, 0);
  
  // 優先權標示
  switch(currentPriority) {
    case PRIORITY_EMERGENCY: display.print(F("EMG")); break;
    case PRIORITY_SAFETY_DOWN: display.print(F("SAF")); break;
    case PRIORITY_COOLING: display.print(F("COL")); break;
    case PRIORITY_MANUAL: display.print(F("MAN")); break;
    case PRIORITY_AUTO: display.print(F("AUT")); break;
  }
  
  // 分隔線
  display.drawLine(0, 9, 127, 9, SSD1306_WHITE);
  
  // ========== 主要資訊區 ==========
  
  // 速度顯示 (大字)
  display.setTextSize(3);
  display.setCursor(0, 12);
  int speedInt = (int)currentSpeed;
  if(speedInt < 10) display.print(F(" "));
  display.print(speedInt);
  
  display.setTextSize(1);
  display.setCursor(50, 15);
  display.print(F("km/h"));
  
  // 速度進度條
  drawProgressBar(0, 33, 60, 5, currentSpeed, 30.0);
  
  // ========== 右側資訊欄 ==========
  
  // 角度
  display.setTextSize(1);
  display.setCursor(65, 12);
  display.print(F("Ang:"));
  display.setCursor(65, 21);
  display.setTextSize(1);
  display.print(compAngleX, 1);
  display.print((char)247); // 度數符號
  
  // PWM 值
  display.setTextSize(1);
  display.setCursor(95, 12);
  display.print(F("PWM"));
  display.setCursor(95, 21);
  display.print(pwmSpeedUp);
  
 /* // 電流 (如果啟用)
  if(!IGNORE_CURRENT_SENSOR) {
    display.setCursor(65, 30);
    display.print(current_A, 1);
    display.print(F("A"));
  } */
  
  // ========== 狀態圖示區 ==========
  display.drawLine(0, 40, 127, 40, SSD1306_WHITE);
  
  // 狀態圖示
  drawStatusIcon(5, 43, currentState);
  
  // 狀態文字
  display.setTextSize(1);
  display.setCursor(15, 44);
  switch(currentState) {
    case STATE_INIT: display.print(F("INIT...")); break;
    case STATE_STANDBY: display.print(F("READY")); break;
    case STATE_RISING: display.print(F("RISING")); break;
    case STATE_UP: display.print(F("TOP")); break;
    case STATE_FALLING: display.print(F("FALLING")); break;
    case STATE_EMERGENCY_STOP: display.print(F("EMERGENCY")); break;
    //case STATE_OVERCURRENT: display.print(F("OVERCUR")); break;
    case STATE_COOLING: display.print(F("COOLING")); break;
  }
  
  // ========== 底部限位開關狀態 ==========
  display.setTextSize(1);
  display.setCursor(0, 55);
  
  // 左側致動器
  if(actuator1.isActive) {
    display.print(actuator1.upLimitPressed ? F("[U]") : F(" - "));
    display.print(F("/"));
    display.print(actuator1.downLimitPressed ? F("[D]") : F(" - "));
  } else {
    display.print(F("OFF"));
  }
  
  // 右側致動器 (如果啟用)
  if(!SINGLE_ACTUATOR_TEST && actuator2.isActive) {
    display.print(F(" "));
    display.print(actuator2.upLimitPressed ? F("[U]") : F(" - "));
    display.print(F("/"));
    display.print(actuator2.downLimitPressed ? F("[D]") : F(" - "));
  }
  
  // 警告圖示
  display.setCursor(95, 55);
  if(tiltWarning) {
    display.print(F("TILT!"));
  } else if(!i2cHealthy) {
    display.print(F("I2C!"));
  } else if(emergencyStopPressed) {
    display.print(F("STOP"));
  } else {
    display.print(F("OK"));
  }
  
  display.display();
}

// ============================================================================
// Setup
// ============================================================================
void setup() {
  wdt_disable();
  Serial.begin(115200);
  delay(100);

  Wire.begin();
  Wire.setClock(100000);
  
  #if defined(ARDUINO_ARCH_AVR)
    Wire.setWireTimeout(3000, true);
  #endif

  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(PWM_PIN, OUTPUT);
  pinMode(LIMIT_LEFT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_LEFT_DOWN_PIN, INPUT_PULLUP);
  pinMode(LIMIT_RIGHT_UP_PIN, INPUT_PULLUP);
  pinMode(LIMIT_RIGHT_DOWN_PIN, INPUT_PULLUP);
  pinMode(HALL_SPEED_PIN, INPUT_PULLUP);
  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);
  pinMode(SPEED_CONTROL_PIN, INPUT);
  pinMode(RGB_RED_PIN, OUTPUT);
  pinMode(RGB_GREEN_PIN, OUTPUT);
  pinMode(RGB_BLUE_PIN, OUTPUT);

  analogWrite(PWM_PIN, 0);
  setRGBColor(RGB_OFF);

  // 只設置速度感測器中斷
  attachInterrupt(digitalPinToInterrupt(HALL_SPEED_PIN), speedInterrupt, FALLING);
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("OLED 初始化失敗!"));
    while(1);
  }

  ina226.init();
  setupMPU();
  calibrateIMU();

  showStartupPro();
  playSound(SOUND_INIT_COMPLETE);

  Serial.println(F("===================================="));
  Serial.println(F("  雙致動器智能控制系統 v7.0"));
  Serial.println(F("  完整修正版 - 單致動器測試模式"));
  Serial.println(F("===================================="));

  Serial.println(F("\n=== 系統配置 ==="));
  Serial.print(F("測試模式: "));
  Serial.println(SINGLE_ACTUATOR_TEST ? F("單致動器") : F("雙致動器"));
  Serial.print(F("電流檢測: "));
  Serial.println(IGNORE_CURRENT_SENSOR ? F("停用") : F("啟用"));
  
  Serial.println(F("\n=== 系統診斷 ==="));
  Serial.print(F("緊急按鈕: "));
  Serial.println(digitalRead(EMERGENCY_STOP_PIN) ? F("HIGH") : F("LOW"));
  Serial.print(F("重置按鈕: "));
  Serial.println(digitalRead(RESET_BUTTON_PIN) ? F("HIGH") : F("LOW"));
  
  Serial.println(F("\n=== 限位開關初始狀態 ==="));
  updateLimitSwitches();
  Serial.print(F("左上 (52): ")); 
  Serial.println(digitalRead(LIMIT_LEFT_UP_PIN) == LOW ? F("觸發") : F("未觸發"));
  Serial.print(F("左下 (53): ")); 
  Serial.println(digitalRead(LIMIT_LEFT_DOWN_PIN) == LOW ? F("觸發") : F("未觸發"));
  
  if(!SINGLE_ACTUATOR_TEST) {
    Serial.print(F("右上 (13): ")); 
    Serial.println(digitalRead(LIMIT_RIGHT_UP_PIN) == LOW ? F("觸發") : F("未觸發"));
    Serial.print(F("右下 (A1): ")); 
    Serial.println(digitalRead(LIMIT_RIGHT_DOWN_PIN) == LOW ? F("觸發") : F("未觸發"));
  }

  Serial.println(F("\n=== IMU 狀態 ==="));
  readIMU();
  Serial.print(F("初始角度: "));
  Serial.print(compAngleX, 2);
  Serial.println(F(" 度"));
  Serial.print(F("I2C 健康: "));
  Serial.println(i2cHealthy ? F("正常") : F("異常"));

  if(abs(compAngleX) > 90) {
    Serial.println(F("⚠️  警告: IMU 角度異常!"));
    compAngleX = 0;
  }

  Serial.println(F("\n【v7.0 改進項目】"));
  Serial.println(F("✓ 修正限位開關檢測 (移除不支援中斷)"));
  Serial.println(F("✓ 完整音效系統 (5種獨立音效)"));
  Serial.println(F("✓ 單致動器測試模式"));
  Serial.println(F("✓ 優化 OLED 介面顯示"));
  Serial.println(F("✓ 修正速度閾值 15 km/h"));
  Serial.println(F("✓ 10秒超時保護"));
  Serial.println(F("=====================================\n"));

  lastI2CSuccess = millis();
  lastLoopTime = millis();
  lastIMUTime = micros();
  
  wdt_enable(WDTO_2S);
}

// ============================================================================
// Loop 主迴圈
// ============================================================================
void loop() {
  wdt_reset();
  uint32_t currentMillis = millis();

  if(currentMillis - lastLoopTime > WATCHDOG_TIMEOUT) {
    Serial.println(F("!!! 看門狗重置 !!!"));
    
    stopAllPWM();
    currentState = STATE_INIT;
    currentPriority = PRIORITY_AUTO;
    tiltWarning = false;
    manualMode = false;
    speedLowCount = 0;
    speedHighCount = 0;
    tiltStartTime = 0;
    safeStartTime = 0;
    syncTimeout = 0;
    
    playSound(SOUND_EMERGENCY);
  }
  lastLoopTime = currentMillis;

  if(!i2cHealthy && (millis() - lastI2CSuccess > I2C_TIMEOUT)) {
    Serial.println(F("!!! I2C 超時 - 重置 !!!"));
    
    Wire.end();
    delay(100);
    Wire.begin();
    Wire.setClock(100000);
    setupMPU();
    
    compAngleX = 0;
    i2cHealthy = true;
    lastI2CSuccess = millis();
    
    playSound(SOUND_BUTTON);
  }

  beepUpdate();

  readIMU();
  readMotorCurrent();
  readSpeedControl();
  updateLimitSwitches();
  checkHardwareLimits();

  if(newSpeedData) {
    currentSpeed = calculateSpeed();
    newSpeedData = false;
    lastSpeedUpdate = millis();
  }

  if(millis() - lastSpeedUpdate > SPEED_TIMEOUT) {
    currentSpeed = 0.0;
  }

  if(currentSpeed < SPEED_DOWN_THRESHOLD) {
    speedLowCount = min(speedLowCount + 1, SPEED_STABLE_COUNT);
    speedHighCount = 0;
  } else if(currentSpeed >= SPEED_UP_THRESHOLD) {
    speedHighCount = min(speedHighCount + 1, SPEED_STABLE_COUNT);
    speedLowCount = 0;
  } else {
    speedLowCount = (speedLowCount > 0) ? speedLowCount - 1 : 0;
    speedHighCount = (speedHighCount > 0) ? speedHighCount - 1 : 0;
  }

  if (!IGNORE_CURRENT_SENSOR && current_A > MAX_CURRENT_A) {
    if (!overCurrentDetected) {
      overCurrentDetected = true;
      previousState = currentState;
      currentState = STATE_OVERCURRENT;
      stopAllPWM();
      Serial.println(F("【警告】電流過載!"));
      playSound(SOUND_EMERGENCY);
    }
  } else {
    overCurrentDetected = false;
  }

  if(IrReceiver.decode()) {
    handleIRCommand(IrReceiver.decodedIRData.decodedRawData);
    IrReceiver.resume();
  }

  if(BUTTON_IS_NC_TYPE) {
    emergencyStopPressed = (digitalRead(EMERGENCY_STOP_PIN) == HIGH);
  } else {
    emergencyStopPressed = (digitalRead(EMERGENCY_STOP_PIN) == LOW);
  }

  if(abs(compAngleX) > SAFE_ANGLE) {
    if(tiltStartTime == 0) tiltStartTime = millis();
    if(!tiltWarning && (millis() - tiltStartTime >= TILT_TRIGGER_TIME)) {
      tiltWarning = true;
      Serial.println(F(">>> 傾斜警告"));
      playSound(SOUND_TILT_WARNING);
    }
  } else {
    tiltStartTime = 0;
    if(tiltWarning && abs(compAngleX) < TILT_SAFE) {
      if(safeStartTime == 0) safeStartTime = millis();
      if(millis() - safeStartTime >= AUTO_UP_DELAY) {
        tiltWarning = false;
        if(!manualMode && currentPriority == PRIORITY_AUTO) {
          wheelDown = false;
          ctrlSrc = 4;
        }
        Serial.println(F("<<< 傾斜恢復"));
        safeStartTime = 0;
      }
    } else {
      safeStartTime = 0;
    }
  }

  decidePriority();
  executeByPriority();
  handleStateMachine();

  setRGBColor(decideRGB());

  if(millis() - lastDisplayTime > 250) {
    lastDisplayTime = millis();
    drawDashboard();
  }

  if(millis() - lastPrintTime > 1000) {
    lastPrintTime = millis();

    Serial.print(F("P:"));
    switch(currentPriority) {
      case PRIORITY_EMERGENCY: Serial.print(F("緊急")); break;
      case PRIORITY_SAFETY_DOWN: Serial.print(F("安全")); break;
      case PRIORITY_COOLING: Serial.print(F("冷卻")); break;
      case PRIORITY_MANUAL: Serial.print(F("手動")); break;
      case PRIORITY_AUTO: Serial.print(F("自動")); break;
    }

    Serial.print(F(" |S:"));
    switch(currentState) {
      case STATE_INIT: Serial.print(F("初始")); break;
      case STATE_STANDBY: Serial.print(F("待機")); break;
      case STATE_RISING: Serial.print(F("上升")); break;
      case STATE_UP: Serial.print(F("頂部")); break;
      case STATE_FALLING: Serial.print(F("下降")); break;
      case STATE_EMERGENCY_STOP: Serial.print(F("緊急")); break;
      case STATE_OVERCURRENT: Serial.print(F("過流")); break;
      case STATE_COOLING: Serial.print(F("冷卻")); break;
    }

    Serial.print(F(" |目標:"));
    Serial.print(wheelDown ? F("下") : F("上"));

    Serial.print(F(" |限位:"));
    if(SINGLE_ACTUATOR_TEST) {
      Serial.print(actuator1.upLimitPressed ? F("U") : F("-"));
      Serial.print(actuator1.downLimitPressed ? F("D") : F("-"));
    } else {
      Serial.print(anyAtTop ? F("T") : F("-"));
      Serial.print(bothAtTop ? F("T2") : F("--"));
      Serial.print(anyAtBottom ? F("B") : F("-"));
      Serial.print(bothAtBottom ? F("B2") : F("--"));
    }

    Serial.print(F(" |速度:"));
    Serial.print(currentSpeed, 1);
    Serial.print(F("km/h"));

    Serial.print(F(" |角:"));
    Serial.print(compAngleX, 1);
    Serial.print((char)176);

    Serial.print(F(" |PWM:"));
    Serial.print(pwmSpeedUp);

    Serial.print(F(" |馬達:"));
    int motorActive = (currentState == STATE_RISING || currentState == STATE_FALLING) ? 1 : 0;
    Serial.print(motorActive ? F("ON") : F("OFF"));

    if(tiltWarning) Serial.print(F(" [傾斜!]"));
    if(manualMode) Serial.print(F(" [手動]"));
    if(emergencyStopPressed) Serial.print(F(" [急停]"));
    if(!i2cHealthy) Serial.print(F(" [I2C錯]"));

    Serial.println();
  }

  delay(2);
}
